{"noir_version":"1.0.0-beta.4+0000000000000000000000000000000000000000","name":"Main","functions":[{"name":"public_dispatch","hash":"6801658800801021834","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"2830029349304997821":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8413411783609869147":{"error_kind":"string","string":"the key have been revoked or never added"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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fJc6x0bn+X7qPF+hc+y031lhU7xLnVOjc7yfOscrdE6d9jsrbEp3qXNudE73U+d0hc65035nhU35LnUujc75fuqcr9C5dNrvrLCp3KXOVzc6l/upc7lC56s77XdW2HT1Xep8DaPz1fdT56uv0PkaTvudFTZdYxc666fau6/O11ij8yPWyPPs8va+evhW50es0Vl/vtbOvjp7Mj2dV+3XvZbTfmeFTdfapc7XNjpfaz91vtYKna/ttN9ZYdO1d6nzdYzO195Pna+9QufrOO13Vth0nV3qfD2j83X2U+frrND5ek77nRU2XW+XOt/A6Hy9/dT5eit0voHTfmeFTTfYpc43MjrfYD91vsEKnW/ktN9ZYdONdqnzTYzON9pPnW+0QuebOO13Vth0k13qfDOj8032U+ebrND5Zk77nRU23WyXOt/C6Hyz/dT5Zit0voXTfmeFTbfYpc63NDrfYj91vsUKnW/ptN9ZYdMtd6nzrY3Ot9xPnW+5QudbO+13Vth0613orJ9T9+6r863X6Lx3jTzPrr2ObA/f6rx3jc7682139tXZk+npvOosjNs67XdW2HTbXep8e6PzbfdT59uu0Pn2TvudFTbdfpc639HofPv91Pn2K3S+o9N+Z4VNd9ylznc2Ot9xP3W+4wqd7+y031lh0513qfNdjc533k+d77xC57s67XdW2HTXXepcGZ3vup8633WFzpXTfmeFTdUudW6MztV+6lyt0Llx2u+ssKnZpc6d0bnZT52bFTp3TvudFTZ1u9T57kbnbj917lbofHen/c4Km+6+S53vaXS++37qfPcVOt/Tab+zwqZ77lLnexud77mfOt9zhc73dtrvrLDp3rvQWT+32Luvzvdeo/MT1sjz7HqCI9vDtzo/YY3O+vN9dvbV2ZPp6bx3hc73cdrvrLDpPrvU+b5G5/vsp873WaHzfZ32Oytsuu8udb6/0fm++6nzfVfofH+n/c4Km+6/S50faHS+/37qfP8VOj/Qab+zwqYH7lLnBxudH7ifOj9whc4PdtrvrLDpwbvU+aFG5wfvp84PXqHzQ532OytseugudX640fmh+6nzQ1fo/HCn/c4Kmx6+C531c7O9++r88DU6P2WNPM8u7/w4D9/q/JQ1OuvPj9rZV2dPpqfzqjPvHuW031lh06N2qfNjjM6P2k+dH7VC58c47XdW2PSYXer8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","debug_symbols":"7f3bjiQ5d2aLvouudWHzSLJfZWGj0QethgBBaqjVG9ho9LtvS1WGR/xKz7QqlnvUmD7jRihJzuRHBm2S5m5j2P/5u//+D//1f/+P//yP//z//sv/+rv/9P/8n7/7p3/5b//l3/7xX/75/N/+z//9+7/7r//6j//0T//4P/7zx//z3x3f/sc45N8b/K//+V/++dv//r/+7b/867/93X8ymevv/+4f/vm/n/9pMs5/4v/9x3/6h7/7T3P+3//P35+NdKeR3Wukc+T3Rud/zh8a+U6j2GmUO43GTqO502htNJJjp5HsNNKdRjsrQnZWhNz/O6XMt0Y5/IdGc6fR2mikx04j2Wm083fSnb+T7vyd9CdXrs73Rutjo7//4cMih8r3T5//7Xn7eB6/9ZGf0Mf4hD7mJ/Sxnt+H7exAtrMD2d2/vPjhb/l8xMVojoh4+/QR68fRjE/oY35CH+v5ffjxCX3IJ/RxdzFKyPHWKubxHxej204j32kUO41yp9HYaXR/Na94u5RljfHrv9CUt89Oe9/yLPzOZ9//lhH5N5/99zALFCYOUhghhVFSGCOFcVKYIIVJUphBCkOqwEGqwEmqwEmqwEmqwEmqwEmqwPnJdWbqW5hpP4QZn3w1rbe71DzGj2GEFOZzr6aMty9hcuiPYYwUxklhghQmSWEGKcwkhXnAeeYYtzDjIoycX7C+1eDzvz8E0mX/HmgetEBCC6S0QEYL5LRAQQuUtECDFmjSAtEq9aJV6kWr1ItWqRetUi9apV60Sr1olXrRKvWiVeoFq9TzgFXqecAq9TxglXoesEo9D1ilngesUs8DVqnnAavU84BV6nnQKrXQKrXQKrXQKrXQKrXQKrXQKrXQKrXQKrXQKrXQKrXSKrXSKrXSKrXSKrXSKrXSKrXSKrXSKrXSKrXSKrXRKrXRKrXRKrXRKrXRKrXRKrXRKrXRKrXRKrXRKrXTKrXTKrXTKrXTKrXTKrXTKrXTKrXTKrXTKrXTKnXQKnXQKnXQKnXQKnXQKnXQKnXQKnXQKnXQKnXQKnXSKnXSKnXSKnXSKnXSKnXSKnXSKnXSKnXSKnXSKvWgVepBq9SDVqkHrVIPWqUetEo9aJV60Cr1oFVqGqM4aYzipDGKk8YoThqjOGmM4qQxipPGKE4aozhpjOKkMYqTxihOGqM4aYzipDGKk8YoThqjOGmM4qQxipPGKE4ao7hojOKiMYqLxiguGqO4DlilXjRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMUF41RXDRGcdEYxUVjFBeNUVw0RnHRGMVFYxQXjVFcNEZx0RjFRWMU5aBBimciWK0+E8GK9ZkIVq3PRLByfSaC1eszEaxgn4lgFftMBCvZZyJczabhimciXM2mAYtnIlzNpiGLZyJczaZBi2ciXM2mYYtnIlzNpoGLZyJczaahi2ciXM2mwYtnIlzNpuGLZyJczaYBjGciXM2mIYxnIlzNpkGMZyJczaZhjGciXM2mgYxnIlzNpqGMZyJczabBjGciXM2m4YxnIlzNpgGNZyJczaYhjWciXM2mQY1nIlzNpmGNZyJczaaBjWciXM2moY1nIlzNpsGNZyJczabhjWciXM2mAY5nIlzNpiGOZyJczaZBjmciXM2mYY5nIlzNpoGOZyJczaahjmciXM2mwY5nIlzNpuGOZyJczaYBj2ciXM2mIY9nIlzNpkGPZyJczaZhj2ciXM2mgY9nIlzNpqGPZyJczabBj2ciXM2m4Y9nIlzNpgGQZyJczaYhkGciXM2mQZBnIlzNpmGQZyJazRYcByk4DlJwHKTgOMjz53VcIlrNFhwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgFcdBKo6DVBwHqTgOUg9azVYcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQRqOgzQcB2k4DtJwHKQdtJptOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoN0HAfpOA7ScRyk4zhIP2g123EcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwHGTgOMnAcZOA4yMBxkHHQanbgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJxHGTiOMjEcZCJ4yDzoNXsxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRzkwHGQA8dBDhwHOXAc5DhoNXvgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOg5w4DnLiOMiJ4yAnjoOcB61mTxwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQC8dBLhwHuXAc5MJxkOug1eyF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w0DlIPGgd5JoLV7DMRrGafiWA1+0wEq9lnIljNPhPBavaZCFazz0Swmn0mwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmwtVsGgd5JsLVbBoHeSbC1WwaB3kmotVswXGQguMgBcdBCo6DlINWswXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkIrjIBXHQSqOg1QcB6kHrWYrjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yANx0EajoM0HAdpOA7SDlrNNhwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBOo6DdBwH6TgO0nEcpB+0mu04DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOgwwcBxk4DjJwHGTgOMg4aDU7cBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAeZOA4ycRxk4jjIxHGQedBqduI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOcuA4yIHjIAeOgxw4DnIctJo9cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0FOHAc5cRzkxHGQE8dBzoNWsyeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yIXjIBeOg1w4DnLhOMh10Gr2wnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuGgdpB42DPBPBavaZCFazz0Swmn0mgtXsMxGsZp+JYDX7TASr2WciWM0+E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E+FqNo2DPBPhajaNgzwT4Wo2jYM8E9FqtuA4SMFxkILjIAXHQcpBq9mC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjFcZCK4yAVx0EqjoPUg1azFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepf5iD/K1VbLXKrVZjq9XcarV2Wv1hvu23VrLVSrda2VarrbVhW2vDttaGba0N21obtrU2fGtt+Nba8K218QhmRNatJvlFTYqI75+NyL/57G9pHJUmUGkSlWag0kxUmkVK8wgu5IFpBJVGUWlQtThQtThQtThQtThQtThQtThQtTg/+Qqfb/d/Me1Omk9exWt+/2we406agUrzuas4I9/SfLhPf0+zSGnGgUojqDSKSmOoNI5Kg/t1APe0u+Kedlfc0+6Ke9pdcU+7K+5pd8U97a64p90V97S74p52V9zT7op72l1xT7sr7ml3xT3trrin3RX3tLvinnZX3NPuinvaXXFPuyvuaXfFPe2uuKfdDfe0u+Gedjfc0+6Ge9rdDlrNNtzT7oZ72t1wT7sb7ml3wz3tbrin3Q33tLvhnnY33NPuhnva3XBPuxvuaXfDPe1uuKfdDfe0u+Gedjfc0+6Ge9rdcE+7G+6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjuLf+GO6tP4Z764/h3vpjOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScRyk4zhIx3GQjuMg/aDVbMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcZOA4yMBxkIHjIAPHQcZBq9mB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjEcZCJ4yATx0EmjoPMg1azE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQA8dBDhwHOXAc5MBxkOOg1eyB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLgOMiB4yAHjoMcOA5y4DjIgeMgB46DHDgOcuA4yIHjIAeOgxw4DnLiOMiJ4yAnjoOcOA5yHrSaPXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBThwHOXEc5MRxkBPHQU4cBzlxHOTEcZATx0FOHAc5cRzkxHGQE8dBLhwHuXAc5MJxkAvHQa6DVrMXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLhOMiF4yAXjoNcOA5y4TjIheMgF46DXDgOcuE4yIXjIBeOg1w4DnLROEg/aBzkmQhWs89EsJp9JoLV7DMRrGafiWA1+0wEq9lnIljNPhPBavaZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZCFezaRzkmQhXs2kc5JkIV7NpHOSZiFazBcdBCo6DFBwHKTgOUg5azRYcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQSqOg1QcB6k4DlJxHKQetJqtOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoM0HAdpOA7ScByk4ThIO2g123AcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwH6TgO0nEcpOM4SMdxkH7QarbjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DjJwHGTgOMjAcZCB4yDjoNXswHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4jjIxHGQieMgE8dB5kGr2YnjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yIHjIAeOgxw4DnLgOMhx0Gr2wHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cBzkwHGQA8dBDhwHOXAc5MBxkAPHQQ4cBzlwHOTAcZADx0EOHAc5cRzkxHGQE8dBThwHOQ9azZ44DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjICeOg5w4DnLiOMiJ4yAnjoOcOA5y4jjIieMgJ46DnDgOcuI4yInjIBeOg1w4DnLhOMiF4yDXQavZC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5cBzkwnGQC8dBLhwHuXAc5MJxkAvHQS4cB7lwHOTCcZALx0EuHAe5aBxkHDQO8kwEq9lnIljNPhPBavaZCFazz0Swmn0mgtXsMxGsZp+JYDX7TISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTISr2TQO8kyEq9k0DvJMhKvZNA7yTESr2YLjIAXHQQqOgxQcBykHrWYLjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAFx0EKjoMUHAcpOA5ScByk4DhIwXGQguMgBcdBCo6DFBwHKTgOUnAcpOA4SMFxkILjIAXHQQqOgxQcByk4DlJwHKTgOEjBcZCC4yAVx0EqjoNUHAepOA5SD1rNVhwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBKo6DVBwHqTgOUnEcpOI4SMVxkIrjIBXHQSqOg1QcB6k4DlJxHKTiOEjFcZCK4yAVx0EqjoNUHAepOA5ScRyk4jhIxXGQiuMgFcdBGo6DNBwHaTgO0nAcpB20mm04DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOgzQcB2k4DtJwHKThOEjDcZCG4yANx0EajoM0HAdpOA7ScByk4ThIw3GQhuMgDcdBGo6DNBwHaTgO0nAcpOE4SMNxkIbjIA3HQRqOg3QcB+k4DtJxHKTjOEg/aDXbcRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAfpOA7ScRyk4zhIx3GQjuMgHcdBOo6DdBwH6TgO0nEcpOM4SMdxkI7jIB3HQTqOg3QcB+k4DtJxHKTjOEjHcZCO4yAdx0E6joN0HAcZOA4ycBxk4DjIwHGQcdBqduA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnAcZOA4yMBxkIHjIAPHQQaOgwwcBxk4DjJwHGTgOMjAcZCB4yADx0EGjoMMHAcZOA4ycBxk4DjIwHGQgeMgA8dBBo6DDBwHGTgOMnEcZOI4yMRxkInjIPOg1ezEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmTgOMnEcZOI4yMRxkInjIBPHQSaOg0wcB5k4DjJxHGTiOMjEcZCJ4yATx0EmjoNMHAeZOA4ycRxk4jjIxHGQieMgE8dBJo6DTBwHmY/gIGXdEvlFooj4/tmI/JvP/pbGUGkclSZQaRKVZqDSTFSaRUrzCM7xgWkElQZViwNViwNViwNViwNViwNViwNVi/OT6818O/3FtDtpPvmaWvP7Z8/fmu+kCVSaz72mzmv4Lc2HU/p7moFKM1FpFinNOFBpBJVGUWk+97tBl/DvH/azk/dPW3zP47A8AcuTsDwDlmfC8nzu94GudrzlUZ8/5vlkiuw6j8DyKCyPwfI4LE/A8iQsz4DlmbA8sPq8YPV5werzgtXn9dn1OeYtz9S/yfPHPv1bei+dPkqnn+D0cvjbV3jnf/74Hd44BJ0+5ZZ+HHfS/9Eq8lsr22rlW61iq1VutRpbreZWq7XT6g/zHb+1kq1WW2tDttaGbK0N2VobsrU2ZGttyNbakK21oVtrQ7fWhm6tDd1aG7q1NnRrbejW2tCttaFba0O31sb951U15W0z0fMLx1/vUmPcfj6aIu87z4rvXcjzu9Dnd2HP78Kf30U8v4t8fhfj+V3M53exnt6F//mrW0zfD7pm8/jYyb2Dper7sfhDIr13Zl23A64veT9D53HvMOz+lnp6+scP/zZW+fyxrlttFVmfOVb9/LHebi/kmBd/V4nxNlZJs1+PdYW9/UCw4sMOdRur/ZVjFf2bsf6WyHGJ/nxZn+sWaK5xp5Tk87sYz+9iPr+L9fQu4nh+F/L8LvT5Xdjzu/jzxWAe81btj/X+FWp8r4ARz+8in9/FeH4X8/ldrKd3kcfzu5Dnd6HP78Ke38Ujru7htzP6IR+7uLPRT337NUVmvOf5drr8McZxu7fXI4+PH/4tfFQOn5XDj8rhZ+Xwq3D4cVQOL5XDa+XwVjl85R12VN5hR+UddlTeYUflHXZU3mFn5R12Vt5hZ+UddlbeYWflHXaid1ixt+8GVT7EuIVH77BX4dE77FV49A57FR69w16EX+gd9io8eoe9Co/eYa/Co3fYq/DoHfYqfOUddlXeYVflHXZV3mFX4R12HoV32HkU3mHnUXiHnUfhHXYehXfYeRTeYedReIedR+Eddh7oHfb9+UW1D08e3/2wHfn2POj52fxxpOjt+JEjFfTe/dCRojf6h44UfSp46EjRR4iHjtTbjBR9OHnoSNEnmYeOFH3seehI25yRpM0ZSduckbTNGUnbnJG0zRlJ25yRtM0ZSduckbTNGUnbnJG0zRnJ2pyRrM0ZydqckazNGekBSpcqI21zRrI2ZyRrc0ayNmcka3NG8jZnJG9zRvI2ZyRvc0Z6gE6pykjbnJG8zRnJ25yRvM0ZyduckaLNGSnanJGizRkp2pyRHmKZqzHSNmekaHNGijZnpGhzRoo2Z6Rsc0bKNmekbHNGyjZnJLar86EjbXNGYltAHzrSNmcktl/0oSNtc0Zim0sfOtI2ZyS2E/WhI21zRmLbVh860jZnJLbH9aEjbXNGYhtiHzrSNmcktnv2oSNtc0ZiW20fOtI2ZyS2L/ehI21zRmKbeB860jZnJLbj96EjbXNGYtuDHzrSNmcktpf4oSNtc0ZiG48fOtI2ZyS2S/mhI21zRmJbmh860i5npMX2Pz90pF3OSIttln7oSLuckdbhbUba5Yy02Dbsh460yxlptfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO9uni28+ji2T5H2uSMdI60yRnpHGmTM9I5Um8z0iZnpHOkTc5I50ibnJHOkTY5I50jbXNG6uLZPkfa5ozUxbN9jrTNGamLZ/scaZszUhfP9jnSNmekLp7tc6RtzkhdPNvnSNuckbp4ts+RtjkjdfFsnyNtc0bq4tk+R9rmjNTFs32OtM0ZqYtn+xxpmzNSF8/2OdI2Z6Qunu1zpG3OSF082+dI25yRuni2z5G2OSN18WyfI21zRuri2T5H2uaM1MWzfY60zRmpi2f7HGmbM1IXz/Y50jZnpC6e7XOkbc5IXTzb50jbnJG6eLbPkbY5I3XxbJ8jbXNG6uLZPkfa5ozUxbN9jrTNGamLZ/scaZszUhfP9jnSNmekLp7tc6RtzkhdPNvnSNuckbp4ts+RtjkjdfFsnyNtc0bq4tk+R9rmjNTFs32OtM0ZqYtn+xxpmzNSF8/2OdI2Z6Qunu1zpG3OSF082+dI25yRuni2z5G2OSN18WyfI21zRuri2T5H2uaM1MWzfY60zRmpi2f7HGmbM1IXz/Y50jZnpC6e7XOkXc5I0sazLW0829LGsy1tPNtyeJuRdjkjSRvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxLG8+2tPFsSxvPtrTxbEsbz7a08WxrG8+2tvFsaxvPtrbxbOvhbUba5YykbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs61tPNvaxrOtbTzb2sazrW0829rGs21tPNvWxrNtbTzb1sazbYe3GWmXM5K18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrXxbFsbz7a18WxbG8+2tfFsWxvPtrfxbHsbz7a38Wx7G8+2H95mpF3OSN7Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb3saz7W08297Gs+1tPNvexrPtbTzb0cazHW0829HGsx1tPNtxeJuRdjkjRRvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxHG892tPFsRxvPdrTxbEcbz3a08WxnG892tvFsZxvPdrbxbOfhbUba5YyUbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGs51tPNvZxrOdbTzb2caznW0829nGsz3aeLZHG8/2aOPZHm082+PwNiPtckYabTzbo41ne7TxbI82nu3RxrM92ni2RxvP9mjj2R5tPNujjWd7tPFsjzae7dHGsz3aeLZHG8/2aOPZHm0826ONZ3u08WyPNp7t0cazPdp4tkcbz/Zo49kebTzbo41ne7TxbI82nu3RxrM92ni2RxvP9mjj2R5tPNujjWd7tPFsjzae7dHGsz3aeLZHG8/2aOPZHm0826ONZ3u08WyPNp7t0cazPdp4tkcbz/Zo49kebTzbo41ne7TxbI82nu3RxrM92ni2RxvP9mjj2R5tPNujjWd7tPFsjzae7dHGsz3aeLZHG8/2aOPZHm0826ONZ3u08WyPNp7t0cazPdp4tkcbz/Zo49kebTzbo41ne7TxbI82nu3RxrM92ni2RxvP9mjj2R5tPNujjWd7tPFsjzae7dHGsz3aeLZHG8/2aOPZHm0826ONZ3u08WyPNp7t0cazPdp4tmcbz/Zs49mebTzbs41nex7eZqRdzkizjWd7tvFszzae7dnGsz3beLZnG8/2bOPZnm0827ONZ3u28WzPNp7t2cazPdt4tmcbz/Zs49mebTzbs41ne7bxbM82nu3ZxrM923i2ZxvP9mzj2Z5tPNuzjWd7tvFszzae7dnGsz3beLZnG8/2bOPZnm0827ONZ3u28WzPNp7t2cazPdt4tmcbz/Zs49mebTzbs41ne7bxbM82nu3ZxrM923i2ZxvP9mzj2Z5tPNuzjWd7tvFszzae7dnGsz3beLZnG8/2bOPZnm0827ONZ3u28WzPNp7t2cazPdt4tmcbz/Zs49mebTzbs41ne7bxbM82nu3ZxrM923i2ZxvP9mzj2Z5tPNuzjWd7tvFszzae7dnGsz3beLZnG8/2bOPZnm0827ONZ3u28WzPNp7t2cazPdt4tmcbz/Zs49mebTzbs41ne7bxbM82nu3ZxrM923i2ZxvP9mrj2V5tPNurjWd7tfFsr8PbjLTLGWm18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/2auPZXm0826uNZ3u18WyvNp7t1cazvdp4tlcbz/Zq49lebTzbq41ne7XxbK82nu3VxrO92ni2VxvP9mrj2V5tPNurjWd7tfFsrzae7dXGs73aeLZXG8/26uLZHkcXz/Y50iZnpHOkTc5I50ibnJHOkXqbkTY5I50jbXJGOkfa5Ix0jrTJGekcaZszUhfP9jnSNmekLp7tc6RtzkhdPNvnSNuckbp4ts+RtjkjdfFsnyNtc0bq4tk+R9rmjNTFs32OtM0ZqYtn+xxpmzNSF8/2OdI2Z6Qunu1zpG3OSF082+dI25yRuni2z5G2OSN18WyfI21zRuri2T5H2uaM1MWzfY60zRmpi2f7HGmbM1IXz/Y50jZnpC6e7XOkbc5IXTzb50jbnJG6eLbPkbY5I3XxbJ8jbXNG6uLZPkfa5ozUxbN9jrTNGamLZ/scaZszUhfP9jnSNmekLp7tc6RtzkhdPNvnSNuckbp4ts+RtjkjdfFsnyNtc0bq4tk+R9rmjNTFs32OtM0ZqYtn+xxpmzNSF8/2OdI2Z6Qunu1zpG3OSF082+dI25yRuni2z5G2OSN18WyfI21zRuri2T5H2uaM1MWzfY60zRmpi2f7HGmbM1IXz/Y50jZnpC6e7XOkbc5IXTzb50jbnJG6eLbPkbY5I3XxbJ8j7XJGkjaebWnj2ZY2nm1p49mWw9uMtMsZSdp4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb2ni2pY1nW9p4tqWNZ1vaeLaljWdb23i2tY1nW9t4trWNZ1sPbzPSLmckbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1t49nWNp5tbePZ1jaebW3j2dY2nm1r49m2Np5ta+PZtjaebTu8zUi7nJGsjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tq2NZ9vaeLatjWfb2ni2rY1n29p4tr2NZ9vbeLa9jWfb23i2/fA2I+1yRvI2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZ9jaebW/j2fY2nm1v49n2Np5tb+PZjjae7Wjj2Y42nu1o49mOw9uMtMsZKdp4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzvaeLajjWc72ni2o41nO9p4tqONZzva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5jHz+HU/85h5/Lqfecw8ft3PPGYe/WseHzKPX/czj5nHr/uZx8zj1/3M75rHc8G9zeO44y0b8nU/85h5/Lqfecg86tf9zGPm8et+5jHz+HU/85h5/Lqfecw8+tc8PmQev+5nHjOPX/czj5nHx9zP3GQissw+Ts1vnczP6GR9QiePeU/vWm9/bj3k6sVSdntde1i+J9KU75EeceLSw24vAD98XkQ65tuHz//8mzcW3rkSQt4GOz8arL+/vGo85EW9+n5t6hHHr+OveLsk1pI782mP+RP7eyD5cR35Z3QSn9HJ3UI83yvaeUXpxy5+azW2Ws2tVmun1f1Xk162kq1WutXKtlr5VqvYarW1NnxrbfjW2vCttRFba+P+68t82ds3jr7me+mKu2/UlbOGvl27cv6a/V5O727+h942f9UPn/0tj8LyGCyPw/IELE/C8gxYngnLs1h57r+65C/MA6vPCavPCavPCavP+dz6/Fsf+Ql9jE/oY35CH+v5fYzjE/p4yHV3u2UXWYf8cp0vGbc75DPQD3nys/Po7bpb5w/0P+QZsDwTlufudRDTb1/iTF8f8/x7q/tCwctWstVKt1rZVivfahVbrXKr1dhqNbdaba2NtbU21tbaWFtrY22tjbW1NtbW2lhba2NtrY21tTbWztqYx7HVSrZa6VYr22rlW61iq1VutRpbreZWq621IVtrQ7bWhmytDdlaG7K1NmRrbcjW2pCttSFba0O21oZurQ3dWhu6tTZ0a23o1trQrbWhW2tDt9aGbq0N3VobtrU2bGtt2NbasK21YVtrw7bWhm2tDdtaG7a1NmxrbfjW2vCtteFba8O31oZvrQ3fWhu+tTZ8a2341trwrbURW2sjttZGbK2N2FobsbU2YmttxNbaiK21EVtrI7bWRm6tjdxaG7m1NnJrbeTW2sittZFbayO31kZurY3cWhtja22MrbUxttbG/e+Ec+jbN8k5TH5s5VutYqtVbrUaW63mVqu10+r+96KXrWSrlW612lobc2ttzK21MbfWxtxaG3NrbcyttbG21sbaWhtra22srbWxttbG2loba2ttrK21sbbWxtpZG+s4tlrJVivdamVbrXyrVWy1yq1WY6vV3Gq1tTZka23I1tqQrbUhW2tDttaGbK0N2VobsrU2ZGttyNba0K21oVtrQ7fWhm6tDd1aG7q1NnRrbejW2tCttaFba8O21oZtrQ3bWhu2tTZsa23Y1tqwrbVhW2vDttaGba0N31obvrU2fGtt+Nba8K214Vtrw7fWhm+tDd9aG761NmJrbcTW2oittRFbayO21kZsrY3YWhuxtTZia23E1trIrbWRW2sjt9bGz55DPvzWKu+08q1WsdUqt1qNrVZzq9XaafWzp10vWslWK91qdb9uzNsDkjn16tnL8xPfPyznLxK3D8tdvvqImy/qyI989fc8DssTsDwJyzNgeSYsz2Ll+cm38X9dHoHlUVgeWH2esPo8YfV5wurzhNXnCavPE1afF6w+L1h9XrD6vGD1eX12fRa7qXlk+I95ApYnYXkGLM+E5VmkPOeP0gcsj8DyKCyPwfKg6vOZB1Wfzzyo+nzmQdXnMw+qPp95YPVZYPVZYPVZYPVZYPVZYPVZYPVZYPVZPrs+681Zpyb66w/bkW9y1POz+WP4WTn8Khxej8rhpXJ4rRzeKof3yuGjcvisHL7yDquVd1itvMNa5R3WKu+wVnmHtco7rFXeYa3yDmuVd1irvMNa5R3WKu+wXnmH9co7rFfeYb3yDuuVd1ivvMN65R3WK++wXnmH9co7bFTeYaPyDhuVd9iovMNG5R02Ku+wUXmHjco7bFTeYaPyDpuVd9isvMNm5R02K++wWXmHzco7bFbeYbPyDpuVd9isvMOOyjvsqLzDjso77Ki8w366ROKh4SvvsKPyDjsq77Cj8g47Ku+ws/IOOyvvsLPyDjsr77CfrgF5aPjKO+ysvMPOyjvsrLzDzso77Kq8w67KO+yqvMOuyjvsp4tcHhq+8g67Ku+wq/IOuyrvsKvwDitH4R1WjsI7rByFd1g5Cu+wchTeYeUovMPKUXiHlaPwDitH4R1Wjso7rFTeYaXyDiuVd1ipvMN+ukzpoeEr77BSeYet7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdJLKTiep7HSSyk4nqex0kspOJ6nsdNLKTiet7HTSyk4nrex00qPwDquVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlrZ6aSVnU5a2emklZ1OWtnppJWdTlbZ6WSVnU5W2elklZ1OdhTeYa2y08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySo7nayy08kqO52sstPJKjudrLLTySs7nbyy08krO528stPJj8I7rFd2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6eWWnk1d2Onllp5NXdjp5ZaeTV3Y6RWWnU1R2OkVlp1NUdjrFUXiHjcpOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nqOx0ispOp6jsdIrKTqeo7HSKyk6nrOx0yspOp6zsdMrKTqc8Cu+wWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1OWdnplJWdTlnZ6ZSVnU5Z2emUlZ1O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e6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o7y0N8pLe6O8tDfKS3ujvLQ3ykt7o6K0NypKe6OitDcqSnuj4qi810Zpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJT2RkVpb1SU9kZFaW9UlPZGRWlvVJb2RmVpb1SW9kZlaW9UHpX32iztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K0t6oLO2NytLeqCztjcrS3qgs7Y3K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UXH+3m7ttbv/TeHvaCeb7fSyXeq9dj/5+833dmvea5eb7cZmu7nZbu21u3+DPVxv68zN7rXzzXb352XG7Xg28167+/eJZ5mft/5y3Wsnm+10s93dc8h5+rz9HVLvrev773L8He1is11uthtb7fL+mwXH+xsFRiy91+7+fI5lt/Vy71yQh2+2i812udlubLabW9dR3jfMXre7b2D9He1ks51utrPNdr7ZLjbb5Wa7dXn93V0v941iv6OdbLbTzXY/qZ+3b/dHjnmv3f3r4Two3277P0j5P7Rbe+3u3xf/jnay2U4329lmO99s95P96Abon+3iXrvcbDf22vlP/n5xW2cj7o3P5bJey99et3d+fTp/Zrh9z3X+BHBvPftP6t/tF6Of7Au+uV/65n7pm/ulb+6Xvrlf/uQ++rLd/fuNi1cS5P3fni9b+Var2GqVW63ufwtlx9u3Cmedmj+2mlut1k6r+z80XraSrVa61cq2WvlWq9hpdf+eac23X7bXx3d/Wby10q1WdtVq3GvlW61iq9VPnvvSt2Zy5B3nzDiOzXY/+QHy9k3ot59x77XTzXa22c432/3kx7G8zYvMu/Ny/2dHu+308vEbjg/t1l67n7xz4rqdbLbTzXa22c43293/+4Xe/u7nl9332uVmu7HZbm62W3vtfuJsvm4nm+3ur5e4vVjp/LJt3Wtnm+18s11stsvNdmOz3dxst/ba/cTt9743y8e9+UM73Wxnm+18s11stsvNdmOz3dxst/ba/cSBdN1uc7345nr5iefG3G/t4l5d+okz5rpdbLbLzXZjs93cbLf22sXmOSQ2zyGxeQ6JzXPI/V9yL5+NHT9hdjNv++bHbwo/tFt77X7Ckl63k8129/8OY9yecx5L77WzzXa+2S422+Vmu7HZbm62W3vtfsLQXLeTzXab62VsrpexuV7G5noZm+tlbK6Xn73V8vjwCse77dZeu5880n2M21fFx8df8N9arZ1WP3nq+qqVbLXSrVa21cq3WsVWq9xqNbZaba2NtbM25nFstZKtVrrVyrZa+Varn31b9U4bDfuxVW61GlutfvI4/vu5S4/xQ6uffEt10ddPvjP68Ni2LP+x1dZs/OR7H3l/W7we+WOrudVq7bT6yTc+P535OwSY3H5PVZG/eWf29y5s54/7k69qrlrFVqvcaWWys5B+8tXHVSvbarW11C22WuVWq7HVam61WjutfvKjq79903/eu/94EJr3b1zfKcwV814r3WplW618q1VstcqtVmOr1dz6yWrG3k9kM4/NdrLZTjfb2WY732wXm+1ys93YbLe5XnJzvQzZqSf3b4zX8bZBLb3baqsy3L9JvexrbLWaW63WTqv7j1VczcbcquRzq5Lff6xi3X5VXuPeirr/WMVlq9hqdVXJ77faquT3v0y4bLV2Wq2ttbG21sbaWhtr61peW7v82trl19Yuv/7o2vi/5//6//0v//qP/+W//tM//K+zybf/7//+5//2b//4L//8/X/9t//f/3z7//zXf/3Hf/qnf/wf//l//uu//Ld/+O//+1//4T//07/8t2//v787vv+P/0fEZv69iB/jTGT//n/59sX2t8e3jm8Zv33o3Ob978//sf499L9/JmT+/Tco9TgTnan+/w==","names":["public_dispatch"],"brillig_names":["public_dispatch"]},{"name":"sync_notes","hash":"5596554994258282116","is_unconstrained":true,"custom_attributes":["aztec::macros::functions::utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/7WTPQ+CMBCGi2KUjzjgoD+jBAyM+LG4OLpXCkpUSAB3frqQXENtwKjAJU17FJ5736OVUB0SzDLqEAyyglmBecTtj8vhQY67hakIdfvku9i2lQZ/Peq3FGBKw/Ax4w/UfzwFzr6o+bwXVndWDo1b66g+H0P5Z/9vSP+LD5418GpAXnmew/oS5Nt74t+Oz8c5SNnXTR1EgnIxdK5CSd0lcZ4SP99QmgZZJhJGDWTUQlU56pVE8YG26fmRdgrSLEpikSZ/Sav6yu6lXLyr8eA57hCOizHTMAb+BDV3X+b2+feXkKuCJ+bT+1Nn6BAztEhI1oRS2yeGwK+CP38vlizs4eEFAAA=","debug_symbols":"rZJLioQwFEX38sYZ5P9xK0VTRI1FIESJ2tCIe+9YxELKpnri5JEXDpdDchdoXT0/7j52/QjVbYHQN3byfczbsiKokw/BP+7Ha8DbIOzJj4ON2zpONk1QEcwJQ+Bi+zwrmjM6HxxURqzohCstC6wxf6GS/oEKKgoqBH6hhKn1CwHhF8hopnYZYT7LcGYKyqU+yYgrZDTfZYz+LCPx/jKSypOMvEDGUFpgw8Q/MhoXVOG3b1rz+m2Tt3VwpV7dHJtD26afwb0Vb0h949o5ua2Ch/bleSMaUZZjc/Qv","names":["sync_notes"],"brillig_names":["sync_notes"]},{"name":"add_zsigk_len64_signed_ecdsa256sha256","hash":"9563769227069326381","is_unconstrained":true,"custom_attributes":["public"],"abi":{"parameters":[{"name":"ksigk","type":{"kind":"struct","path":"Main::Bytes64DnsKey","fields":[{"name":"domain","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":241,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]},"visibility":"private"},{"name":"domain_rrset_position","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"ksigk_rrset_position","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"rrset_dnskey","type":{"kind":"struct","path":"Main::DnskeyRecordSetBytes","fields":[{"name":"bytes","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":333,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]},"visibility":"private"},{"name":"rrsig_dnskey","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"zsigk_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"zsigk_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"zsigk_rrset_position","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"8413411783609869147":{"error_kind":"string","string":"the key have been revoked or never added"},"13699457482007836410":{"error_kind":"string","string":"Not initialized"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16954218183513903507":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/+ydBaBlN7X+73Rm6tOZugLFHbYLWqClUCiFUihWYCtWKLS4Du7u7u7u7u7u7u7+/32ns89J9yS3M6/7wsn7v/Ne6Jl7v5u9kp2srPWtZGXdypmfXdavrKzb9n3Dtv/uve2/+vlvV876GbBHbftvcM4+4YR1BWsl4zoPZNzFAxnXeyDjBg9k3OiBjLt6IONuHsi4uwcy7uGBjHt6IONeHsi4twcybvJAxn08kHGzBzJu8UDGfT2QcT8PZNzfAxkP8EDGAz2Q8SAPZDzYAxkP8UDGQz2Q8TAPZDzcAxmP8EDGc3kg47k9kPE8Hsh4pAcyntcDGc/ngYzn90DGC3gg4wU9kPFCHsh4YQ9kvIgHMl7UAxkv5oGMF/dAxkt4IOMlPZDxUh7IeGkPZAw8kDH0QMbIAxljD2RMPJAx9UDGzAMZcw9kLDyQsfRAxst4IONlPZDxch7IeHkPZLyCBzJe0QMZj/JAxit5IOOVPZDxKh7IeLQHMh7jgYxX9UDGYz2Q8WoeyHh1D2Q8zgMZr+GBjNf0QMbjPZDxWh7IeIIHMl7bAxmv44GMJ3og43U9kPEkD2S8ngcyXt8DGU/2QMYbeCDjDT2Q8UYeyHhjD2S8iQcynuKBjDf1QMabeSDjzT2QsfJAxtoDGRsPZGw9kLHzQMbeAxlv4YGMt/RAxlt5IOOtPZDxNh7IeKoHMt7WAxlv54GMp3kg4+09kPEOHsh4ugcynuGBjHf0QMY7eSDjnT2Q8S4eyHhXD2S8mwcy3t0DGe/hgYz39EDGe3kg4709kPE+Hsi41QMZ7+uBjPfzQMb7eyDjAzyQ8YEeyPggD2R8sAcyPsQDGR/qgYwP80DGh3sg4yM8kPGRHsj4KA9kfLQHMj7GAxkf64GMj/NAxsd7IOMTPJDxiR7I+CQPZHyyBzI+xQMZn+qBjE/zQManeyDjMzyQ8ZkeyPgsD2R8tgcyPscDGZ/rgYzP80DG53sg4ws8kPGFHsj4Ig9kfLEHMr7EAxlf6oGML/NAxpd7IOMrPJDxlR7I+CoPZHy1BzK+xgMZX+uBjK/zQMbXeyDjGzyQ8Y0eyPgmD2R8swcyvsUDGd/qgYxv80DGt3sg4zs8kPGdHsj4Lg9kfLcHMr7HAxnf64GM7/NAxvd7IOMHPJDxgx7I+CEPZPywBzJ+xAMZP+qBjB/zQMaPeyDjJzyQ8ZMeyPgpD2T8tAcyfsYDGT/rgYyf80DGz3sg4xc8kPGLHsj4JQ9k/LIHMn7FAxm/6oGMX/NAxq97IOM3PJDxmx7I+C0PZPy2BzJ+xwMZv+uBjN/zQMbveyDjDzyQ8YceyPgjD2T8sQcy/sQDGX/qgYw/80DGn3sg4y88kPGXHsj4Kw9k/LUHMv5mDWRcCzl/O6Gcku3IlbN+ppb3dx68+997IOMfPJDxjx7I+CcPZPyzBzL+xQMZ/+qBjH/zQMa/eyDjPzyQ8Z8eyPgvD2T8twcyqsJll3GdBzLu4oGM6z2QcYMHMm70QMZdPZBxNw9k3N0DGffwQMY9PZBxLw9k3NsDGTd5IOM+Hsi42QMZt3gg474Tyvif4CL386BP9/dAxgM8kPFAD2Q8yAMZD/ZAxkM8kPFQD2Q8zAMZD/dAxiM8kPFcHsh4bg9kPI8HMh7pgYzn9UDG83kg4/k9kPECHsh4QQ9kvJAHMl7YAxkv4oGMF/VAxot5IOPFPZDxEh7IeEkPZLyUBzJe2gMZAw9kDNdAxrWQM/JEznhibvf4dSsraylv4sEYTT2QMfNAxtwDGQsPZCw9kPEyHsh4WQ9kvJwHMl7eAxmv4IGMV/RAxqM8kPFKHsh4ZQ9kvIoHMh7tgYzHeCDjVT2Q8VgPZLyaBzJe3QMZj/NAxmt4IOM1PZDxeA9kvJYHMp7ggYzX9kDG63gg44keyHhdD2Q8yQMZr+eBjNf3QMaTPZDxBh7IeEMPZLyRBzLe2AMZb+KBjKd4IONNPZDxZh7IeHMPZKw8kLH2QMbGAxlbD2TsPJCx90DGW3gg4y09kPFWHsh4aw9kvI0HMp7qgYy39UDG23kg42keyHh7D2S8gwcynu6BjGd4IOMdPZDxTh7IeGcPZLyLBzLe1QMZ7+aBjHf3QMZ7eCDjPT2Q8V4eyHhvD2S8jwcybvVAxvt6IOP9PJDx/h7I+AAPZHygBzI+yAMZH+yBjA/xQMaHeiDjwzyQ8eEeyPgID2R8pAcyPsoDGR/tgYyP8UDGx3og4+M8kPHxHsj4BA9kfKIHMj7JAxmf7IGMT/FAxqd6IOPTPJDx6R7I+AwPZHymBzI+ywMZn+2BjM/xQMbneiDj8zyQ8fkeyPgCD2R8oQcyvsgDGV/sgYwv8UDGl3og48s8kPHlHsj4Cg9kfKUHMr7KAxlf7YGMr/FAxtd6IOPrPJDx9R7I+AYPZHyjBzK+yQMZ3+yBjG/xQMa3eiDj2zyQ8e0eyPgOD2R8pwcyvssDGd/tgYzv8UDG93og4/s8kPH9Hsj4AQ9k/KAHMn7IAxk/7IGMH/FAxo96IOPHPJDx4x7I+AkPZPykBzJ+ygMZP+2BjJ/xQMbPeiDj5zyQ8fMeyPgFD2T8ogcyfskDGb/sgYxf8UDGr3og49c8kPHrHsj4DQ9k/KYHMn7LAxm/7YGM3/FAxu96IOP3PJDx+x7I+AMPZPyhBzL+yAMZf+yBjD/xQMafeiDjzzyQ8eceyPgLD2T8pQcy/soDGX/tgYy/8UDG33og4+88kPH3Hsj4Bw9k/KMHMv7JAxn/7IGMf/FAxr96IOPfPJDx7x7I+A8PZPynBzL+ywMZ/+2BjCu7LL+M6zyQcRcPZFzvgYwbPJBxowcy7uqBjLt5IOPuHsi4hwcy7umBjHt5IOPeHsi4yQMZ9/FAxs0eyLjFAxn39UDG/TyQcX8PZDzAAxkP9EDGgzyQ8WAPZDzEAxkP9UDGwzyQ8XAPZDzCAxnP5YGM5/ZAxvN4IOORHsh4Xg9kPJ8HMp7fAxkv4IGMF/RAxgt5IOOFPZDxIh7IeFEPZLyYBzJe3AMZL+GBjJf0QMZLeSDjpT2QMfBAxtADGSMPZIw9kDHxQMbUAxkzD2TMPZCx8EDG0gMZL+OBjJf1QMbLeSDj5T2Q8QoeyHhFD2Q8ygMZr+SBjFf2QMareCDj0R7IeIwHMl7VAxmP9UDGq3kg49U9kPE4D2S8hgcyXtMDGY/3QMZreSDjCR7IeG0PZLyOBzKe6IGM1/VAxpM8kPF6Hsh4fQ9kPNkDGW/ggYw39EDGG3kg4409kPEmHsh4igcy3tQDGW/mgYw390DGygMZaw9kbDyQsfVAxs4DGXsPZLyFBzLe0gMZb+WBjLf2QMbbeCDjqR7IeFsPZLydBzKe5oGMt/dAxjt4IOPpHsh4hgcy3tEDGe/kgYx39kDGu3gg4109kPFuHsh4dw9kvIcHMt7TAxnv5YGM9/ZAxvt4IOPWNZBxLeS874RyrjPkWit57+fBu7+/BzI+wAMZH+iBjA/yQMYHeyDjQzyQ8aEeyPgwD2R8uAcyPsIDGR/pgYyP8kDGR3sg42M8kPGxHsj4OA9kfLwHMj7BAxmf6IGMT/JAxid7IONTPJDxqR7I+DQPZHy6BzI+wwMZn+mBjM/yQMZneyDjczyQ8bkeyPg8D2R8vgcyvsADGV/ogYwv8kDGF3sg40s8kPGlHsj4Mg9kfLkHMr7CAxlf6YGMr/JAxld7IONrPJDxtR7I+DoPZHy9BzK+wQMZ3+iBjG/yQMY3eyDjWzyQ8a0eyPg2D2R8uwcyvsMDGd/pgYzv8kDGd3sg43s8kPG9E8oo2Y5cOetnannf50Gfvt8DGT/ggYwf9EDGD3kg44c9kPEjHsj4UQ9k/JgHMn7cAxk/4YGMn/RAxk95IOOnPZDxMx7I+FkPZPycBzJ+3gMZv+CBjF/0QMYveSDjlz2Q8SseyPhVD2T8mgcyft0DGb/hgYzf9EDGb3kg47c9kPE7Hsj4Xc+4yO950Kff90DGH3gg4w89kPFHHsj4Yw9k/IkHMv7UAxl/5oGMP/dAxl94IOMvPZDxVx7I+GsPZPyNBzL+1gMZf+eBjL/3QMY/eCDjHz2Q8U8eyPhnD2T8iwcy/tUDGf/mgYx/90DGf3gg4z89kPFfHsj4bw9kXFm//DKuWwMZ10LOXdZIzpX1688q9C76GWUDZSNlV8pulN0pe1D2pOxF2ZuyibIPZTNlC2Vfyn6U/SkHUA6kHEQ5mHII5VDKYZTDKUdQzkU5N+U8K2eSuOelnI9yfsoFKBekXIhyYcpFKBelXIxyccolKJekXIpyaXUKJaRElJiSUFJKRskpBaWkXIZyWcrlKJenXIFyxW0v6kqUK1OuQjmacgzlqpRjKVejXJ1yHOUalGtSjqdci3IC5dqU61BOpFyXchLlepTrU06m3IByQ8qNKDem3IRyCuWmlJtRbk6pKDWlobSUjtJTbkG5JeVWlFtTbkM5lXJbyu0op1FuT7kD5XTKGZQ7Uu5EuTPlLpS7Uu5GuTvlHpR7Uu5FuTflPpStlPtS7ke5P+UBlAdSHkR5MOUhlIdSHkZ5OOURlEdSHkV5NOUxlMdSHkd5POUJlCdSnkR5MuUplKdSnkZ5OuUZlGdSnkV5NuU5lOdSnkd5PuUFlBdSXkR5MeUllJdSXkZ5OeUVlFdSXkV5NeU1lNdSXkd5PeUNlDdS3kR5M+UtlLdS3kZ5O+UdlHdS3kV5N+U9lPdS3kd5P+UDlA9SPkT5MOUjlI9SPkb5OOUTlE9SPkX5NOUzlM9SPkf5POULlC9SvkT5MuUrlK9Svkb5OuUblG9SvkX5NuU7lO9Svkf5PuUHlB9SfkT5MeUnlJ9Sfkb5OeUXlF9SfkX5NeU3lN9Sfkf5PeUPlD9S/kT5M+UvlL9S/kb5O+UflH9S/kX5N0WTfx1lF8p6ygbKRsqulN0ou1P2oOxJ2YuyN2UTZR/KZsoWyr6U/Sj7Uw6gHEg5iHIw5RDKoZTDKIdTjqCci3JuynkoR1LOSzkf5fyUC1AuSLkQ5cKUi1AuSrkY5eKUS1AuSbkU5dIURYJCSkSJKQklpWSUnFJQSsplKJelXI5yecoVKFekHEW5EuXKlKtQjqYcQ7kq5VjK1ShXpxxHuQblmpTjKdeinEC5NuU6lBMp16WcRLke5fqUkyk3oNyQciPKjSk3oZxCuSnlZpSbUypKTWkoLaWj9JRbUG5JuRXl1pTbUE6l3JZyO8pplNtT7kA5nXIG5Y6UO1HuTLkL5a6Uu1HuTrkH5Z6Ue1HuTbkPZSvlvpT7Ue5PeQDlgZQHUR5MeQjloZSHUR5OeQTlkZRHUR5NeQzlsZTHUR5PeQLliZQnUZ5MeQrlqZSnUZ5OeQblmZRnUZ5NeQ7luZTnUZ5PeQHlhZQXUV5MeQnlpZSXUV5OeQXllZRXUV5NeQ3ltZTXUV5PeQPljZQ3Ud5MeQvlrZS3Ud5OeQflnZR3Ud5NeQ/lvZT3Ud5P+QDlg5QPUT5M+Qjlo5SPUT5O+QTlk5RPUT5N+Qzls5TPUT5P+QLli5QvUb5M+Qrlq5SvUb5O+Qblm5RvUb5N+Q7lu5TvUb5P+QHlh5QfUX5M+Qnlp5SfUX5O+QXll5RfUX5N+Q3lt5TfUX5P+QPlj5Q/Uf5M+Qvlr5S/Uf5O+Qfln5R/Uf5N0cK/jrILZT1lA2UjZVfKbpTdKXtQ9qTsRdmbsomyD2UzZQtlX8p+lP0pB1AOpBxEOZhyCOVQymGUwylHUM5FOTflPJQjKeelnI9yfsoFKBekXIhyYcpFKBelXIxyccolKJekXIpyaUpACSkRJaYklJSSUXJKQSkpl6FclnI5yuUpV6BcUcY05UqUK1OuQjmacgzlqpRjKVejXJ1yHEWX3utSeV3arkvRdem4LvXWpdm6lFqXPutSZV1arEuBdemuLrXVpbG6lFWXnupSUV3aqUsxdenkzSm6NFGXEurSP12qp0vrdCmcLl3TpWa6NEyXcunSK10qpUubdCmSLh3SpT66NEeX0ujSF12qoktLdCmILt3QpRa6NEKXMujSA10qoKT9SoqvpPNbKUqYriTkSvKtJNpKUq0k0EqyrCTGShKsJLxKcqskskrSqiSoSjKqJJ5KkqkklEryqCSKSlKoJIBKsqckdkoSpyRsSnKmJGJK0qUkWEoy9RyKkiQpCZGS/CiJjpLUKAmMkqwoiYmShCgJh5JcKImEkjQoCYKSDOgQvw7J6xC6DnnrELUOKesQsA7Z6hCrDonqEKYOOeoQoQ7p6RCcDpm9h6JDUjp4pIM9Ojijgyk6+KGDFTq4oIMB2nivje3aOK6N2dr4rI3F2rirjbHaeKqNndo4qY2J2vinjXXauKaNYdp4pY1N2jikjTna+KKNJdq4oY0R2mygYL6C5QpGK9irYKqClQoGKtimYJaCRQrGKNihYILIepHhIptF5oosFRkpsk9kmsgqkUEiW0RmiCyQMy5nV86kjH45Q7sY/sD4s27bf/++35n/3WPbv3cxfq8/P2rbv4Nz9gn3GD13yvqLOIv3sLRvQvln9avOTWtRf7yof5+1kT/YbVs9N9+6qN9sy/Dc9SPc+G/WGZjKwFQOTG1gagemMTCNA9MamNaB6QxM58D0BqZ3YG5hYG7hwNzSwNzSgbmVgbmVA3NrA3NrB+Y2BuY2DsypBuZUB+a2Bua2DsztDMztHJjTDMxpDsztDcztHZg7GJg7ODCnG5jTHZgzDMwZDswdDcwdHZg7GZg7OTB3NjB3dmDuYmDu4sDc1cDc1YG5m4G5mwNzdwNzdwfmHgbmHg7MPQ3MPR2YexmYezkw9zYw93Zg7mNg7uPAbDUwWx2Y+xqY+zow9zMw93Ng7m9g7u/APMDAPMCBeaCBeaAD8yAD8yAH5sEG5sEOzEMMzEMcmIcamIc6MA8zMA9zYB5uYB7uwDzCwDzCgXmkgXmkA/MoA/MoB+bRBubRDsxjDMxjHJjHGpjHOjCPMzCPc2Aeb2Ae78A8wcA8wYF5ooF5ogPzJAPzJAfmyQbmyQ7MUwzMUxyYpxqYpzowTzMwT3Ngnm5gnu7APMPAPMOBeaaBeaYD8ywD8ywH5tkG5tkOzHMMzHMcmOcamOc6MM8zMM9zYJ5vYJ7vwLzAwLzAgXmhgXmhA/MiA/MiB+bFBubFDsxLDMxLHJiXGpiXOjAvMzAvc2BebmBe7sC8wsC8woF5pYF5pQPzKgPzKgfm1Qbm1Q7MawzMaxyY1xqY1zowrzMwr3NgXm9gXu/AvMHAvMGBeaOBeaMD8yYD8yYH5s0G5s0OzFsMzFscmLcamLc6MG8zMG9zYN5uYN7uwLzDwLzDgXmngXmnA/MuA/MuB+bdBubdDsx7DMx7HJj3Gpj3OjDvMzDvc2Deb2De78B8wMB8wIH5oIH5oAPzIQPzIQfmwwbmww7MRwzMRxyYjxqYjzowHzMwH3NgPm5gPu7AfMLAfMKB+aSB+aQD8ykD8ykH5tMG5tMOzGcMzGccmM8amM86MJ8zMJ9zYD5vYD7vwHzBwHzBgfmigfmiA/MlA/MlB+bLBubLDsxXDMxXHJivGpivOjBfMzBfc2C+bmC+7sB8w8B8w4H5poH5pgPzLQPzLQfm2wbm2w7MdwzMdxyY7xqY7zow3zMw33Ngvm9gvu/A/MDA/MCB+aGB+aED8yMD8yMH5scG5scOzE8MzE8cmJ8amJ86MD8zMD9zYH5uYH7uwPzCwPzCgfmlgfmlA/MrA/MrB+bXBubXDsxvDMxvHJjfGpjfOjC/MzC/c2B+b2B+78D8wcD8wYH5o4H5owPzJwPzJwfmzwbmzw7MXwzMXxyYvxqYvzowfzMwf3Ng/m5g/u7A/MPA/MOB+aeB+acD8y8D8y8H5t8G5t8OzGwDy+j7GLPOwKxzYHYxMLs4MOsNzHoHZoOB2eDAbDQwGx2YXQ3Mrg7MbgZmNwdmdwOzuwOzh4HZw4HZ08Ds6cDsZWD2cmD2NjB7OzCbDMwmB2YfA7OPA7PZwGx2YLYYmC0OzL4GZl8HZj8Ds58Ds7+B2d+BOcDAHODAHGhgDnRgDjIwBzkwBxuYgx2YQwzMIQ7MoQbmUAfmMANzmANzuIE53IE5wsAc4cCcy8Ccy4E5t4E5twNzHgNzHgfmSANzpANzXgNzXgfmfAbmfA7M+Q3M+R2YCxiYCzgwFzQwF3RgLmRgLuTAXNjAXNiBuYiBuYgDc1EDc1EH5mIG5mIOzMUNzMUdmEsYmEs4MJc0MJd0YC5lYC7lwFzawFzagQkMTODAhAYmdGAiAxM5MLGBiR2YxMAkDkxqYFIHJjMwmQOTG5jcgSkMTOHAlAamdGAuY2Au48Bc1sBc1oG5nIG5nANzeQNzeQfmCgbmCg7MFQ3MFR2YowzMUQ7MlQzMlRyYKxuYKzswVzEwV3FgjjYwRzswxxiYYxyYqxqYqzowxxqYYx2YqxmYqzkwVzcwV3dgjjMwxzkw1zAw13BgrmlgrunAHG9gjndgrmVgruXAnGBgTnBgrm1gru3AXMfAXMfArDcwJxqYEx31XNfAXNeBOcnAnOTAXM/AXM+Bub6Bub4Dc7KBOdmBuYGBuYEDc0MDc0MH5kYG5kYOzI0NzI0dmJsYmJs4MKcYmFMcmJsamJs6MDczMDdzYG5uYG7uwFQGpnJgagNTOzCNgWkcmNbAtA5MZ2A6B6Y3ML0DcwsDcwsH5pYG5pYOzK0MzK0cmFsbmFs7MLcxMLdxYE41MKc6MLc1MLd1YG5nYG7nwJxmYE5zYG5vYG7vwNzBwNzBgTndwJzuwJxhYM5wYO5oYO7owNzJwNzJgbmzgbmzA3MXA3MXB+auBuauDszdDMzdHJi7G5i7OzD3MDD3cGDuaWDu6cDcy8Dcy4G5t4G5twNzHwNzHwdmq4HZ6sDc18Dc14G5n4G5nwNzfwNzfwfmAQbmAQ7MAw3MAx2YBxmYBzkwDzYwD3ZgHmJgHuLAPNTAPNSBeZiBeZgD83AD83AH5hEG5hEOzCMNzCMdmEcZmEc5MI82MI92YB5jYB7jwDzWwDzWgXmcgXmcgTFtpMcbmMc7ME8wME9wPOuJBuaJDsyTDMyTHJgnG5gnOzBPMTBPcWCeamCe6sA8zcA8zYF5uoF5ugPzDAPzDAfmmQbmmQ7MswzMsxyYZxuYZzswzzEwz3FgnmtgnuvAPM/APM+Beb6Beb4D8wID8wIH5oUG5oUOzIsMzIscmBcbmBc7MC8xMC9xYF5qYF7qwLzMwLzMgXm5gXm5A/MKA/MKB+aVBuaVDsyrDMyrHJhXG5hXOzCvMTCvcWBea2Be68C8zsC8zoF5vYF5vQPzBgPzBgfmjQbmjQ7MmwzMmxyYNxuYNzswbzEwb3Fg3mpg3urAvM3AvM2BebuBebsD8w4D8w4H5p0G5p0OzLsMzLscmHcbmHc7MO8xMO9xYN5rYN7rwLzPwLzPgXm/gXm/A/MBA/MBB+aDBuaDDsyHDMyHHJgPG5gPOzAfMTAfcWA+amA+6sB8zMB8zIH5uIH5uAPzCQPzCQfmkwbmkw7MpwzMpxyYTxuYTzswnzEwn3FgPmtgPuvAfM7AfM6B+byB+bwD8wUD8wUH5osG5osOzJcMzJccmC8bmC87MF8xMF9xYL5qYL7qwHzNwHzNgfm6gfm6A/MNA/MNB+abBuabDsy3DMy3HJhvG5hvOzDfMTDfcWC+a2C+68B8z8B8z4H5voH5vgPzAwPzAwfmhwbmhw7MjwzMjxyYHxuYHzswPzEwP3FgfmpgfurA/MzA/MyB+bmB+bkD8wsD8wsH5pcG5pcOzK8MzK8cmF8bmF87ML8xML9xYH5rYH7rwPzOwPzOgfm9gfm9A/MHA/MHB+aPBuaPDsyfDMyfHJg/G5g/OzB/MTB/cWD+amD+6sD8zcD8zYH5u4H5uwPzDwPzDwfmnwbmnw7MvwzMvxyYfxuYfzsws+Q1o+9jzDoDs86B2cXA7OLArDcw6x2YDQZmgwOz0cBsdGB2NTC7OjC7GZjdHJjdDczuDsweBmYPB2ZPA7OnA7OXgdnLgdnbwOztwGwyMJscmH0MzD4OzGYDs9mB2WJgtjgw+xqYfR2Y/QzMfg7M/gZmfwfmAANzgANzoIE50IE5yMAc5MAcbGAOdmAOMTCHODCHGphDHZjDDMxhDszhBuZwB+YIA3OEA3MuA3MuB+bcBubcDsx5DMx5HJgjDcyRDsx5Dcx5HZjzGZjzOTDnNzDnd2AuYGAu4MBc0MBc0IG5kIG5kANzYQNzYQfmIgbmIg7MRQ3MRR2YixmYizkwFzcwF3dgLmFgLuHAXNLAXNKBuZSBuZQDc2kDc2kHJjAwgQMTGpjQgYkMTOTAxAYmdmASA5M4MKmBSR2YzMBkDkxuYHIHpjAwhQNTGpjSgbmMgbmMA3NZA3NZB+ZyBuZyDszlDczlHZgrGJgrODBXNDBXdGCOMjBHOTBXMjBXcmCubGCu7MBcxcBcxYE52sAc7cAcY2COcWCuamCu6sAca2COdWCuZmCu5sBc3cBc3YE5zsAc58Bcw8Bcw4G5poG5pgNzvIE53oG5loG5lgNzgoE5wYG5toG5tgNzHQNzHQfmRANzogNzXQNzXQfmJANzkgNzPQNzPQfm+gbm+g7MyQbmZAfmBgbmBg7MDQ3MDR2YGxmYGzkwNzYwN3ZgbmJgbuLAnGJgTnFgbmpgburA3MzA3MyBubmBubkDUxmYyoGpDUztwDQGpnFgWgPTOjCdgekcmN7A9A7MLQzMLRyYWxqYWzowtzIwt3Jgbm1gbu3A3MbA3MaBOdXAnOrA3NbA3NaBuZ2BuZ0Dc5qBOc2Bub2Bub0DcwcDcwcH5nQDc7oDc4aBOcOBuaOBuaMDcycDcycH5s4G5s4OzF0MzF0cmLsamLs6MHczMHdzYO5uYO7uwNzDwNzDgbmngbmnA3MvA3MvB+beBubeDsx9DMx9HJitBmarA3NfA3NfB+Z+BuZ+Dsz9Dcz9HZgHGJgHODAPNDAPdGAeZGAe5MA82MA82IF5iIF5iAPzUAPzUAfmYQbmYQ7Mww3Mwx2YRxiYRzgwjzQwj3RgHmVgHuXAPNrAPNqBeYyBeYwD81gD81gH5nEG5nEOzOMNzOMdmCcYmCc4ME80ME90YJ5kYJ7kwDzZwDzZgXmKgXmKA/NUA/NUB+ZpBuZpDszTDczTHZhnGJhnODDPNDDPdGCeZWCe5cA828A824F5joF5jgPzXAPzXAfmeQbmeQ7M8w3M8x2YFxiYFzgwLzQwL3RgXmRgXuTAvNjAvNiBeYmBeYkD81ID81IH5mUG5mUOzMsNzMsdmFcYmFc4MK80MK90YF5lYF7lwLzawLzagXmNgXmNA/NaA/NaB+Z1BuZ1DszrDczrHZg3GJg3ODBvNDBvdGDeZGDe5MC82cC82YF5i4F5iwPzVgPzVgfmbQbmbQ7M2w3M2x2YdxiYdzgw7zQw73Rg3mVg3uXAvNvAvNuBeY+BeY8D814D814H5n0G5n0OzPsNzPsdmA8YmA84MB80MB90YD5kYD7kwHzYwHzYgfmIgfmIA/NRA/NRB+ZjBuZjDszHDczHHZhPGJhPODCfNDCfdGA+ZWA+5cB82sB82oH5jIH5jAPzWQPzWQfmcwbmcw7M5w3M5x2YLxiYLzgwXzQwX3RgvmRgvuTAfNnAfNmB+YqB+YoD81UD81UH5msG5msOzNcNzNcdmG8YmG84MN80MN90YL5lYL7lwHzbwHzbgfmOgfmOA/NdA/NdA7PewHzPwHzPUc/3Dcz3HZgfGJgfODA/NDA/dGB+ZGB+5MD82MD82IH5iYH5iQPzUwPzUwfmZwbmZw7Mzw3Mzx2YXxiYXzgwvzQwv3RgfmVgfuXA/NrA/NqB+Y2B+Y0D81sD81sH5ncG5ncOzO8NzO8dmD8YmD84MH80MH90YP5kYP7kwPzZwPzZgfmLgfmLA/NXA/NXB+ZvBuZvDszfDczfHZh/GJh/ODD/NDD/dGD+ZWD+5cD828D824GZXVw1+j7GrDMw6xyYXQzMLg7MegOz3oHZYGA2ODAbDcxGB2ZXA7OrA7ObgdnNgdndwOzuwOxhYPZwYPY0MHs6MHsZmL0cmL0NzN4OzCYDs8mB2cfA7OPAbDYwmx2YLQZmiwOzr4HZ14HZz8Ds58Dsb2D2d2AOMDAHODAHGpgDHZiDDMxBDszBBuZgB+YQA3OIA3OogTnUgTnMwBzmwBxuYA53YI4wMEc4MOcyMOdyYM5tYM7twJzHwJzHgTnSwBzpwJzXwJzXgTmfgTmfA3N+A3N+B+YCBuYCDswFDcwFHZgLGZgLOTAXNjAXdmAuYmAu4sBc1MBc1IG5mIG5mANzcQNzcQfmEgbmEg7MJQ3MJR2YSxmYSzkwlzYwl3ZgAgMTODChgQkdmMjARA5MbGBiByYxMIkDkxqY1IHJDEzmwOQGJndgCgNTODClgSkdmMsYmMs4MJc1MJd1YC5nYC7nwFzewFzegbmCgbmCA3NFA3NFB+YoA3OUA3MlA3MlB+bKBubKDsxVDMxVHJijDczRDswxBuYYB+aqBuaqDsyxBuZYB+ZqBuZqDszVDczVHZjjDMxxDsw1DMw1HJhrGphrOjDHG5jjHZhrGZhrOTAnGJgTHJhrG5hrOzDXMTDXcWBONDAnOjDXNTDXdWBOMjAnOTDXMzDXc2Cub2Cu78CcbGBOdmBuYGBu4MDc0MDc0IG5kYG5kQNzYwNzYwfmJgbmJg7MKQbmFAfmpgbmpg7MzQzMzRyYmxuYmzswlYGpHJjawNQGRr/fw8CbPz9q27+Dc/ApgixY2zvV+nDTtjo3LZo4b8vw7M1r8+xo3eh5KyuGX2z8d3j+niNZp5UnCNeNnjfIM+6fXbb9d/jZ+q0LedaNfrdh6/btGH630fjd8H51r/kt1i9w47G1aeWsvxtk0WfIf7bHylnH76RjMkyjtR2TUfDfG5NR+L9xTK4f/W7D1u3bsbNj0uyT4W+Hd7NhDfqiCPP/G3crfo27DaPfbdi6fTt2dtyZY2usCzeuLD5DnqPhd7sav3v8SE/uZtQ53XgtkzUdr2HS/tfGa5h0/xvH626j323Yun07dna8mmNrPF53X1l8htjj8N72WIN+KqJujXVo8l/Uocn/Sh26x+h3G7Zu346dHZPm2Bqv3XuuQV8UcfR/a/eKX+Nuz9HvNmzdvh07O+7MsTUed3utQV8UcfJ/427Fr3G31+h3G7Zu346dHXfm2BqvwXuvLD4Dt6M6Tl+/+P6Cbd/XlOuJs3iof5c1qF+f/S3ym8/SZ7eti/4YxtJ642dDnw/9uLuJH/1uD+N3G7ae9Tl7bvv3BuM5Zl2DHBtH+DtsAw9jYVfjb4a/32J5/q6j559FbsvPxv2yhwW/hwUvP+PW2wAad8Nae5Wti/qm5O+G+o+euP6sCsouy/Kh/mMmrr+us7zqinSo/6oT1x83WdfHZ3IG+hw7cf1VmvR9GldD/VebuP40DLo0yvuh/qtPXH9ZB2lWFM1Q/3ET1x/2RdyWVT3Uf42p+6fugqYNy0HXXHNb/cMz9BmeffzEz972KXdk/TWfv+dI1rVYf83nmfKY/TNef6+1dXtZt1h+d7Qh9/h36y0/G55jq+uYCeu66oR1HTthXVebsK6rT1jXcRPWNczrtZ1rSbDH6NkTz51kqP+ENak/Lob6r70m9Yfz/rnO2vRPN9R/4rb6V3a87vDsKh/qvu5ayB4u6j9pbfomHuq/nlH/TvTP2X6G+q9v1L9uDeo/eW36Z17/DbbVvxZ9c0ND9gnrn9vXN1qbvpnXf+Ota/Ju53rnJmsifzTv/1O21T9d30fzvrnp9HXP/YKbrUW/EJuR7yfu4BH7nlmfeIZh/azufNsTbt+c1nZXatvTuzPOMG3FMVe12mdn6ty8E3UeMq7zWnc69dRb9bfqTj/mrrc6447b1b3FUvfwfZcVe9vGcpk487Nx9IyXGbzM47b17eaV7ftt3ei7+dz1lp+ZNs747wec7Tnrz+Fz1u/gczacw+ds2MHnrEW/bVqxv3t91niPUbxu9LyhHSsrq3Oka8MXr86R2vp16J8ta9M/0bpR/aY8Wyz9M7zLfS2/G+rab9u/Nxp1mfgtRhtNvPl9+HvzZx/Y9uK2jOrUZ7At1ll+t97yM5Ove9eILzbfzTrHf4d6xz8bzwezb4b3u8Z7+iJbTGKw7dTej61fPNd8H+b7MmMEuxi/N/F32HdR5ycNXtY1dmxjwdT7tnjAnMvd9t8NW9ekz2KtJ0/cdyHHdmPReK7K/sbv1lvwJn+scoAFb9Yx8MNbRnizv2xjanjm5hW7HjVlsOmczRaZbWvTgFtbfRTGmyx9M3w2Wfpm/eh3Bxr4wSZdZ6lr/ejfZps0Fl5ujIUxbiyP2ecHjH63xfK3Qx/uO2rHUdv+HZyTTxju8Jo3PH/PlbV8p4s1z6aTzf4Zr3n7r03/RKvN4f0t/WMbd+a7M8edqUNN/P5GG038eMxuHP3sN6M1z9Qj4zXPpmPMn5lr3s9Ga575bs7pmmdb689uTfrjTq5J+xi/N/G1sSb9ZRS3XZPxzXg6u7b9fdS2/VZpmz6Drz62f04w2vav0Xpr2hJD/6+pngkW7TbXveEz1uP6vmH0O3NsDj7+jurqoU3nRFfvP/qdbQ4MfWjaqNONnXiHdfXw/D1X1vKdLnT1fiN5xv3zn9HV8Q7r6kFem642391a6uoDtw3wqXX15g1nbZv5bs6prjb7ZrzeufTZYRvO2pbh71y62tTlJv4oQ5+da1uda7tnOj5bXX3kTrRNn7GuHvCXNNp2/m112mz08bj9j9uLUZb/b7EX10RHR1m2mk60zZ811YlINPZ1xmND5aBt/zbHrYnfz+hDE29+H/7e/Fk20kWm3hzqn1L/7UhdB1rqMts6vAfNxUuO5P9P2b2rzes1GbdxWf1PbYu1nte2efQf9wPjstxZ22KQ54C1kAeJhrFykOXZg6wHb/u3Oa9N/Nh2Odj43cFGOzeOfnb8aF6Y82eof8vK9vNtZ+biINd/oq4bjuo6yFKX2W/DO5WOuPJ/yN4yuc3xHDhq23+DIu7yMgzbIk6DMs+isg+CLE/jsG/CtKn6Ni+roqy7rqkZ0kHcZ2WaR00WZ31SpdV4Dpl1h1Xep11fVW3ex1QWpVUZFn0cNE3R5nEc901T1Tm/bsqgJ6jZFWHdNGlU9GUZp+14PpxF7jSpqiKr8ripiypO0ijt0rru2qxL4roKw7Loiizo0z4uUxbZos/Dtk/SMqzbLgnm+/YPtNQdBWXb9HUf8T9p3pd9FiS0NmnzsGqyvuqLPOLxfZMnQd4ESVdnUVhlUZE3VRNG2VD3QbY+aZKkj6o04i+LsImKqoj547Sgf7qiDuMwDKJEDeFrEZZ13VZ9WkVVWxVJnhRD3Qfb+iSuqq6Lsy5LoqgK2yAswyyOkDkty6oru5oX1kRNmFdFU0ZBVcW84KIuyibtEWSo+xBbn2Qt0oVZ0GQF8vIOs7TPmjrJw4iu6ALaUvZJHBfqqKQKo6bk9fZR1NdZX8/7+1Dru2zyoInrsglaxkjShEHQxVWU133cNHEu4fqiadsy4a02SVAwJKO4zZMsoQH9UPdh1nfZtWWT0RtRHuXq/bKo+6YL0rxo07Ktw6qtO4ZSHid93ldNwyyoy7osk77ps26o+3Bb3WXT5m2cB2Vc1HFaNFnUJBVsfx5XQRsGVV3lXVpVVZDkAb/Iw7gvyrCru7qM4jwc6j7C1icR3VpUdZM1vKA2DeI8bmluy4ut6jDN1Dl5VMd12Od1kYXMMSiTNA/SqI2L+V7/c9nkRlYmel0GXcWrKcs2y9KgYuihCsowqYMoTLs6qPIyKMKg5t0zcAoseb7l4Vzuc9vk7sMg67M2yWomNRoiKpmqUVJSTR/FRc7b5K0mScq/mZRB0iQZj0/7JAsY5kPd57H2d1UXDK486sMW7ZFEjLuySWh/n+dhQAcwqtssTNEGdEaWx2GXFBkPrRmJ+VD3kdb+Los+6pg4CRowDcumUPe3pbqaNxaEKJaC4BdTsmjCMqHHsyotUwZonJXzOX9eW91xWjNs64JZXyVd0zGyW8ZFX6FW47bvwrgMGM0xbQkZ2k3KNO1qVERVNUVcD3Wfz9YnTYniSfISrYa+6Ko87/I6KENmTp8w6qs8oT/qkFlQRAz0KAqaKCzyIuyzflH3+W1150VfZHRuW9KjQZ22VRQjMuqqi9OkbdK2qQN0ACOzzlE7UdG2dd/XYcBwzOd9cgFbn9SdtFMfI1ScoqSqNK7yLOu7PGFOlkWcF0zuikHKCKpoV91nIYOKedPXyXwMXtBWd894StIgSLuizFhYeKdlmsVo3qovq7ZtWefqPGWaJkVep7QySKuYNyqlGM1zolzI1idl3xdJnFed3mlRlkWYJGEdxUGc0bd13rf8Al3b90FXxGg0/s1DWEnqNgvm+uTClrrDvo2SPE6pJe8YvVkdRS1VN33etEnB75I+TeIuZiDWCMxwYQ5hiMdBRnfO5b6ITW7edZt0DPKiKRJ0VZsWfHKNdhbptIiqJE6zNGfSoGSDokuDrkzQhIzIpC2Hui9qlTuNmeBZG6JH6wStl1Rt2aHs0kr/G5U8gKGJMRGmjCKWkSII6xIbIoiCdD4GL2aTG4VRBoidRCljLElyFrAUXV4gasGKx5Kctl2c1zU6nHkDgMUbiVAWZTwfJxe3jZOqSvKO1bINo7ZIM5Z7DBDNaeZ20MjkycqY/mmrTk/GCOixWroYiyBs67k+uYStbhlPRZuhmbMewyZrypBOjds64CUW9DB2UNFlQRujX+iKOkdnBn1XVlnaZc1Q9yVtfdL02FEBVkpblQnre8lKhmnG4tAyW5KWxQwTKpY5USZhHrRFGVVBlLc8FG051H0pm9xtmBcxYzZC7zGNQgyohlFetNhBoRa0DJuKFSJhHJWaiw1rU8+oR6fk4TwnwaVtcnc1uiLp+4SX1zcxVhOjsokbdAy0Qx0iYISeijCpWCakafuAlbirsgKTbd4ngaXuWBsTAnqDoVDVDFoUFl2gxZHZkzE6mjLuEtQ2GhKtkGPXFRlTiZev8T/UHVrqDsM8qrI6y5MmoyaW4jAoe9rSlnGLkkJ7YLHpbQSFpmMWFthaGBhpyCeb27GRre6YmuMC8zHDeisqtFLL+p1VMVZ3wphIWb6SiqnZp5HsIGyvtmCOsczmTKmh7tjW37ykNMHz66sSC6tjWKCbE9nbAcYh0yRrZSBjHhMpkBLP4iZHBi338cLWTGx113HOAtDVScMMb2rMXxyHIu0a7NYgjTumDOtRhXdBS6Iux49g+jIKY8ZkM3+Xqa1umcY5FaGmMZDjqsQCxhCquladmlcY+FjMQRU0YZ0HVZj3zPwMV6LDrMrndWe2urOqC5smSeO2qmOZ+AkmDot4LyNCBhTGEx9UQx+zChcY96ycNf+sWP/m+iS31Y1lWWstSeRkxExrzEtecIfJFyRl02ONM/i7qsxYPbMQnVaVad1EXcDYr+fjpLDUHXQRCz1tRNPnrDhMlaKOmIM9EvZBhJ8WhB0LcIh9xPDPsOUwWVhNOuZUOLe/S0vdOEt9mvL6Wbo1U+j8nEnHBMFtC5o0Q9sVKFTZFczemkWeFRjLMcNULBbr/GVscqdpw3BiGGBwxF2ntTeoKwxlzGV0HwZKgMGWMIww6bo8w/ZnocK7YO02/J3LWvs7xpouZL/iiMmrQzxGRpemTHNcE+w5BmLaprgULFF4GCj8Bo+zwCsI5mva5Wx1o06pENMOryziHTVYKpiRrJOYRW3MIsQE0hqjxzUdZmIGMtMqVTfdfG24vK1uXEuZqLhJzBrGHAY5HxRIUjIHNdhwY1kH+qTOMlxAxip+LmYMZjJ2+lD3FWx1J+gLLIOu7bAuq4QhiIHd8IQMm7NB/7NIJ2mesITWsrkSVgcGZ5ditGAMDHVf0fYuaWCOwmYu1hHmJX0dYSbgTZVlpKFeBXWStU2LR95i7sYRgybuWZkq/OV4rquOssrNEly1ASZl1kUoQlbNGcdQsAwXGLYYc13BaEkLTCPoCXRZUqZY04XWqfm6cyWb3PJP21w6A22C2oPw6EMIDrQfI6PFFe8bpm2DuRLI+QnCfmadl02tHh/qvrKt7hSLtEDuMmPCYF1ipYV1JxuO1hC8x3Dret4vsIjlAU1A9+BLRBhf3WK9vIqlbpZb5MQ/ZWhlGns4HjUDGiOB9TmIijCSBcRLCRtGUovV2QbyF0vWbEyVoe6jbXInHYRMyIxk1tMTdRLVmYxrRO8D7IkiY9j0QYNPhn2OVScjoAxYA2Ej6rmOPcba3zKXADFYWJVr+gD7suzboq9EdqBkeJn481iavBAs0CYtUtQmDFAaFHNddVXbOMHf4X3jr9YsY/JG6GRc1lJuOzZ4hwMInZCLk2CA5y16LShhJmRCYpwPdR9rk7vIy6aEgOqwCqsy70PsLKwG7PJATjicbhBHOJl526GOSxZjVgcMCZRBkC3m5dVscrMQlEy0IGn7gqWrz0V1RPgRDWo6CxEZPYj3HWGG17Ig4MPgz7BvsSmKuX1ydds4CeBk8hBtKNuPRUpsAcYH6rNmKS6jDCs7zDClWSlkDsBWFB3tSxlawcLnPs5WN68edghrtslKMV/Y7ehcRltN5UGSFDG/Z2ZiMkCAMZdKTLwIcyhnWFXzteEatrrBMsBjNDPsIwZT1IWoVuy3GN3PQtrBu/EOaswvuqTFsCojDEf6EaOpnY+Ta1rfZdrgB8p9QXUwmunFtpGlzOKe6HR4WZaZfiymEVsZhxudlUjFYlzP9ffxtndJ+wraWzMbWEbQR2jTOmSaYjeILmXg4XrD1qDHsVNC0Z9F1malKJRwbn9fy9Yn2K6wsagfpqLIuwSmLsEAxGNt2y6Ec+h6jdAGO7FCEMzcGA+54e2ymM7n5Qk2uWucYlb5XA4rxlvJM2BgcEBCjCuITJi6gpGOSRsmLHy1rIpaih7FGTVzPXhtm9w471gOvPEaBS3GUSxMiF2D1YSTjLXIcMCcT/HB4YgwOXjRLB3Ya7Lwh7qvY6sbS7gpGmwShErpEtQf5EWXZLnMNBzrGkcqwwVt5RK2dEgK24Y+Z4TyPoa6T7T1Sc8iGVQllhvrsPwbxhjVsUwmTBos81JzizGIKskgeDstP7xQGI8grObv8ro2ubsCZQR1UdbQa3kUdVkq8oelEQuoYuC3crEx+TveBC8HXgaFXM6YxKCb25on2eSWgQxNmjWMM2yGjiUNyTo4PdwQET0o1CKF0MC+wPWXlcJ8quVS9dGiT65nk5tVtoH+xJtC9ffYnTh5mtA0GrIBEhDFwWrBE4hey4IL6a9UqgdaJ5vrqutb+1sGQyRfDGoQlxh3m/FbZ2Kt4L7xTGqomnJGkeVVKPsrLGAsMGBwj+c228mWuuHZUPEoib5sYjqcb8xI7M4OPzCAC4T0IIgRt3gVIRMdn4vVg+EIoSzgUPcNbHUDZS1mzqPuYpHKek+8vCYQC87Ia2tcZ0w5NGaIF8CCA5lcF1EEIZfM14Yb2voEUxWuCBGZ8cRIcIBlJtCnMCeQGxiveGUsO8z5FNoOr455HOGe0Jy6mnNKN7K9S5Yq/F9UPbKx5ojKpS0dkQecnloRDYwWiIgST5Nls5RTl6HZYlYP9M9Q941tcse8PMV0QpwdVoK0xJhSlCirMFzQvhgBSc+kibo+xFNpNImZsz3mJ3TRvL9vYpNbxHkOxwHxnOLVwIymGOMh4xz2FaZXyyIOFFXz7456MXygBxNUGYprPr5Psb1L1m3ZSZEiXYxaVuMwaVjbGARYWHgoKO9UYz5mecC9pI/xXwlO1PKU5jbETW190rMEEzCCWEiIhjDYowgKEqquln+GNukzXjeaidHftrh+DXaBOrDMUe1zHXszW59U4kMj1GgmkwOPFY2ImQ9Z2jP1Ianxz3DhqReSmTWSCcrQRnlCm1cLu+rmtj5hfBOvwD6Bs2cUJzHMCYoEzh47BF3bEKsTuanfYZ8nZdx0WGw5L0eBh6HuytYnCTqDGR1r1WI4MgKxfvuINaUmgqc53kAAN6juqOexCIHpH+MOYBJE7Vyf1NY+6aD2O/g+rBzNNZRXidFKvAv7LaFP4pCKEwxNHE/4B1gybK0QXkusx9w+aWx9ojAoVCssTCJjGUcSxYdfgs1chwSViA9kkNOs0CyUjLsqhQzuRJhhlMdzX6q19UnAXMYpgSImLoWxWcIgY+KjHlO1PEdhw59iCAYtTESLA0rXYUWUGuD9fO501rpnERBaikVbyVqqcFgxmpmOUB24fyxGeBOa9URHO41Y2Ep6H06WYTDU3dvqZoYHZR0jDxYwjCAaH38aEikWfU1zWqxFJmVFqANXFo6qrJhwop/wuOZ21S2sdbNO9tAxsBaxwquo/5SXFmDxISy8K4RxkWDh4wmx6rAgJawkkBYBfteCZ7ul7V0y9QLWqZ6BTAwQm09EQ5PzcisMCb27kvEDbSI3B78NZRXKVsGb4OXP7apb2eomsszw7Qn9QY0QeokDvFlmZQzxEog9ZMLS6xmOTonB3GIFwa8zbbB5w4VPcmtb3QmuH6QUk4xlAP0n3oH6GJUJagVGDRcIYoXn0DWQ5JUIF2rF5a2TxTi5jaVudDQ0eh3BFci2Z6EnJCNzJ2YS9bivjP9GXcGqR3wXuqkn5MuLzwmmsagMdZ9qkxurVS4dqrsoCXElHdEvQqUEn9EtWFF4TVWD8wqd1CnEROgDcQmnYiQyiIa6b2sbJ1DwLMJEazK8O/68x30N5EuWotQxC2MFFzHJMYngZDEomKwx8dwCa7Gd21W3s9VdKlgXa7ihHWRnok5YP/HWiMgHWcCMlRLIeXij/RGdVADuJzOqjcN5n5xm65MUB31GmMMAYvQqBAtxGUGF18S9WNXLEmMhwBcpIlxlrAwWDgIHOMd0/HwM3t4mN6Qm41YhZuKMmKYYk0lZiaZGYYdoGvgjLQtYbASVCVmzOjDwcTaYp+m87jvY6k7wnQlkiIKB+Ebp4yAHeAXEu4jmohFS1nr+ha/PJyrQCIwd4iiQEISUh7pPt9QdYrERMNZ+AWxT1nkWyBKbSkyvuihoIUtD/QrGG+oaP7ZoSkW7UMrhgq86wya34okYNUwTdEQIHa3Xj/0RsdrQ26lCDzO/MyTOgf8ish53QgFg+nA+Bu9oe5dhIvKhZ00MGL64qKw/VQyLiffNF22XYN3VYOIV4P3U8Ng5ndZBMYcLPXgnW5/ICasyBjS9ifUDpYhzh4ABTgp6sdF8YqXPiZ4xlwi1F8SOqLSFZagX8fk72+pm0jVhB1sHFUushTh5CCGRZ2VP7Ax7gZ7BMMLT1GSBuhWvilLmWYWaMNR9F1ufpASDiYoQiMPUxp4l0tjCiML+Z7hVNY4m3BTdjnkEJcbqSYwNUpaJi0dVzbmwu1rrpvewegjCtNpiQhQ3IUra9jlWISt63RCAgTeFnqBygpstL6Dl3zgosOBzG/lu1v6Gnpxtv4F1rCCqC3hfVK48lYx1l0oZ4TFjBApCtFndst5rVmjLxMKfv7t1nKTaDIPGQCr0XlHSVNhi1vQc+xp9SOgYg4KANRqmzGMswgrmCpWFrRLM9ck9bHInGNHoZHyFDssVP424PG4BrB4qlzEfE0jB14ehIaautTiE/4B1iWDe4oU+uael7kjsaNLBiESwjEyLhOHQyqCImPJdCptZaIoHRE0SCENeOVMJIoUBShRi/i7vZas77TXnUEs4lz2KW1GXBjIcGr/DWYOJRB1goPdiY6GqcTMDWOyoJDJWR/PxfW9b3ThRbcmslBHCmq/kQLhVjAd4TqyhWJpDIUCUYSAaDs6NN4qlDvmH3T/UfR/bu8QiIYTIuhayfENqQl7BBebQ07h8JQZ5xixNGgx+FnwcHfqfsDdjh+WhCuZr8Vbbu4xDzQcixk0WE3LvsJO1H4xIYMNqh7XI2ybaBrNX642wbKtTWm0DCoN+rk/ua+sT0bqIBXkvtwC7I65ZXDrt14KZJbDN2tXmohAI9PAPopEKTCksDo0z75P72eSOFHaBLMaTjzJpexxBAt6s7yFUCWaV6Bp+Q/APt5JwR6z6WdSYvHU71yf3t8ldtmGoGQg9TxSHeALdzhKXEJAiugY93WpAQwWygCrMAf3G5GnjBEMAk2ao+wE2udsOnYlJUOK+o1rwPhoRXyl8JguM0n1DCOUR8zHJeQctKkEMDU/XEjvXJw+0yZ21gULFGR4VCz2+Mes7bBRPw4RImPcBGhw5UcAanL3ILDqE+dUrRDvU/SBb3XUMU6Q4DGJABhK4JH5dat8A9cEsIbri/0FKPALPKmTcwFkTd0gbRvjcv3ywre68IZzCMoM4jNlUCxq2KlYUA7hl6rA+50xcmlY0InkzVtQM5Y0B3BnxhofY6kYGZjPWOmNvtsizkEG4EXaBtG76FAIxTMQGYu7zGgtxb5pcWjWLhR58qO1dNopJsRZoe2AFj4snBa/dQDIQMcG4IVhQhQxs1G3OQ7E08dDSNoADxySb9/fDLHXTjwE0QCrWAv8sZ5VPWB6whaCwsPeIa6UpI515D/tT8JNQ2wsZufCUbTLv74fb+oRZMJvhBDoxZ2pFKeSWlQVGJqsQOh0OIsVkkJ9fYBn3OLahYhy49cVcnzzCWrf28Wq3R0y/49V1NdYQfUOAOKLDERk1meDHiQ3CHYH/YdRo0RN5Nq/7kbY+iWdbeHAaCbEyraHriF02Mws/TMTVNSyZLGAtXxLeaqeQXp9l2kTBwj3U/Sib3KyvmBzIxjAsC7hYbanFlA2YMfIkQpQ1NBJh+gYKGeWq8C8zt4E6SMr52vBom9x45pGoME0WOpD4q/aaBQzrrhC30aAQicjijLN4EuqQpdImqGMGU7uIMT7GUjf2NoRfGrG+4840+NWsjRgm+Fhdn8kzqUR74qNhBQTMs4z51ciZ1Sbfhf39WFuftCinhjAt7naN7RFnIr1LMR3auIGSViSHl4GWTQgeJUQ7C0yBeLZVeWFrPs4mN8oBTyaIsB3h7XH1FJBh5WUpF70Wd/wsFWfMwxAWRkJBFEUhcg3Woe7H2/objzqBCpXGoKNhixEJcw+vtS9xJQj4E+NOFaDRLtAyTuQTwtinmP/NIgbzBGufsFDCi8AO4Kg2eYjagmGI8bCwsuRCopSIs2IMJhC8pUhheRRECZhp7Vx/P9HWJygL6H0CltACEJeEZAr8S2Z4UWv7M79BmfOlYamDR8JeLwlHKXw4oxaGup9kqxt3MUnQR8xH2Ia8UHA+T4mNhjkKoxYZi3XWahNQgyHNhCHmQZgb/y+q2vk4ebKtT7QjEJtN/FOp1xTCCmpEENjnNfAsAqyJfHe4VUX94VpwHTDVmVPRYpw8xSY3sQzoJ5pfoFC1q0oBQSZ/qN328L3wbfibkXbfKrbd6pQA/AIBKpq14PCeaqtbzEmVY8/jPzHXu5ZgEcIzBrDgiB43UQLZiOFMCF1ckMKmnTbhagdGPNexT7PUDceCHx9hTUUNChuisM1YOHOmS4UDLxUGeUAkHdWUYO/j3WciO4n7YiK28zXt6Ta5tRWTsdfCcYlgxHsotX81iWmAtlnUrP2FSCGMXQ2jBLOLoD4OgeyM+bt8hu1dYotRWKCI/YW8QrxrxoqErqHGeQ62rY5SMPAYgJBacAd4n7hpPWpormOfaaubEJ128mj/t/YGtzBMUB4lLxRDSvsfSkUty0ChRviKHtoAmjzHdYX7XOx1fpatv1l8G2Z0hPmBE4ixidIizsqcQRnRajQJUUwWa4ZRESjoSExdrnxMULOe6+9n2/q7qGT4Ujm+KGqzkQ+YwoZJhxKfREWVRcNDtJcQQYgjR5BuHc4cnu7CPnmOre5IkYsAxyZIZVby3lgmCN0SiKpZ8vEYsCly7TRjOeuLqiNMU2sbPUFPjPKh7ufa6kbXKyQadYok9mhWKAA8Pv6DZxKLnkH14rinOLE5MQkGJp5WhRoI626hB59n6++E4DZqA1ZQQore0KEdVAFdIpYDojCCWmKlZt3EPKffK5ZVaVp+MLd9nm+rO8Pba7UDBGog1lbPWlwVdEoNDVOjIQme1WLRtaEOS4NZCV+B0AQgUVlD3S+w1R2mFQwb2hBaOFFMHr6YIalNYPB5lUJT+JY1Vgo+uZY9vmjfS6k9e9H8Xb7QUjfBBp1twEKFqtL+cW2jkiVepnBIcAdEYrCN8SL6qtChA4L1MSYtyycNSuZ98iKb3JjEYZPKRGH9hX+BPoN6IyaHzRm32u5b9aX2QkV4yoxpJn6BJtBGmBJbdqj7xba6SzVN+50aImmNSHRCfKGCJawQ9H1ZycvB+GJRSiMML8Y/Cx7jE1JkcW/iS2x1s4YUOE2YsJVeH2Sg0r+3igmzMFcK3CsglbUsaoRRmP7yPIljsMRi+w51v9TW3yVRNwJoRPhR9S2jHHNFDqDOqjSQvgRO0SB5xsgnrMQLER+GjwurWaGeh7pfZqk7VFBV3DkOBEFtRk0TFIjLDCzlyUdoAIg9Rb1bMb6EaIouwtBCIDjDuc32clvdCjaHKaMMtRLBMhBhgdtoUlGMeV9oJx9OPJErhnSFPSQ+jAWzy7VDqJmPk1fY+gSTRm47ZEGlgxf0IvZSx1hoiILJCWGEE4qCJ00JkMawG2gseE/YEwidue/6Sus4oYURDrQI+lwn4WrRJXGJBci41xG0COUXYHrm8oWCKEY/6OwWgYqsmK8Nr7L2CawP+p61TfsZsRtwk7VtGjITrzXUZuUeOi/HL8QR1bJK0IdhqeMrdNBQ96ttdRMCbiEJNV9aFgIWhBDrqcbPnO0Tka+DL1wzhfBZFC1gtWehgiTsc2Mfx2ts/c0AxktnwskP4FVigEOEFdorRueix4m+EByAc4ccxLHsZWrBqRKvhXearzuvtdQd67YHpiHhWwLN6Wy1FZlMjBLjqmPCE5jRORliVbXs3ET2dDqLIPBi5rbm62zvEmKEtQcSFladqYMpiQ+LVsKj1m4GXJrozNAaWrbUeTJMY4JBWJD8Kpzz36+31Y3PooMktDSJ4fASnf9jjZdlgmbBtcajjOqe8UMAqyW6rI1NUkJQj+iyoe432Po70V4zTMgo0TKjnetd2lUzNq+s6Yek0WAkiBbMdkqhYVHmEcE28aGLtfiNNrlLOAL8QPwO7EDiU6mYWSx31lxRhgTtypa1jFgeqxl8ITYMzpe4iJIA23ycvMlWNxYkegMvDY8Mzx0WslG4NddZzz4MFQvB6ZE9rjAx35hrlXYQB3i2wVzuN1vfZcerQ6fqwGsD9xVpFzz+ZaQDCaw+OLU6ZtTD7GFFE1LCG+j1mgntERAe6n6LrW7tG8JtrGS6NsQRiDrkuTZxIn2dy8ePMG8TnQtIeVqgOB0KEB8zUFB5qPuttncpRkcrDH+OboNiKLU3nqh2AjtdJnR6UcBg6uwU3EwKtQ4ZGVREMmum/nxteJtNbulXPOkcfwyiALdJjkivAKiO2uCMsIJCG0CnlNqKlcb4bKmMCwh3Yx/1221yE+GUaxRDXBGLj+DUy37GdCEqCwJ0ILo74ZUw3rXxKYbzxWEgBokCW3DU77DUDenFzAl589gSNeRuHsc1NjaxkbqDgYU9pGmslnASnYJA0jhYFEwBeqea98k7bX3CQCm1QUAWAtM6rXRIoNVIhxuF5SDYFsSzLXQt1qCmIpoA2iBstYzO5/y7bH3CGq9xhn8W6wga5KCmNqF/iJ9QfGGi89A6X5z0M3cixQCnw2JcjWDB+7zbWneGtsCYTsX2xfLAKh3w1lY/+ieLa3zvSsQkgzzArdBBvpg5WhOLwVAd6n6PrU8wpSpCNVg3HaaNTmfU2ujU6iAq44OlH/uWAYkFrsM7BEgQuZCpFxBQmffJe211h3qFTBKItnoWpcAehjfu+Ip93GnXIjaKSFVtZSFuIEuaqHrfBLgA83X+fbZxok3r0No6Yl0qMokhhjmrbau5LEvGp87/VToeDsERZDpnit+oELqG0lD3+239rU1wQYpQKHvankHfM0IqmBgMLd3hA5nFuojxlXXETyKoUhgnls06gBqez/kP2PoEWzQRx4tGxm0iKBRokaS9slV6WKFM21qIjOJptrg6kCIsbKk2nBOXndsnH7TJje3LrCHgWihWlmMAEq5QPBD+lPlaEhPhxeUEjjOd523R3RlKl8gp9mgytyE+ZKsbAyTWjkdMNixV7VWS3ubN4uPJWdKJekgYwru1Tg3hF7c6XI+tgW262B/7Yeu71EbVTMd/sdozIqsl3EaNmYyLjyWnE05Jp/M3MHs97gsDhTmv/cJdVi9szY/Y5O4qyadTPDCtTEG8ENhcuTS8Cd4pxAHDn/HPWGzQWyHhmbzAqtJW7mLe3x+1vUsGVqtNBYQTgpxVtlNQnW7H/ckxqkS0YQDASxRpLOoX2gdlggmT6cD7fAx+zDpOcGsKLIIuDVKc4Fwh0aCNUKoV8RG8tCjTbjcMHkyWAIpNp+FTlAM9ly3OS33c1t+w5ljwkCWQlLBnWudR1x2dHOt4sLYPorlkdkFP9zoRXaQzTlW0+8J3/YStblQrExsmvklF5zD4oj7W4qBtgwpaardRqNhLhNFAdKpuwkLKpZChO1/nP2mrO5RFrGNLREa1cQjjkqgMS7ScVSrAHw/z2bKEylUmGHzNbqZ4Y5yZed2fsvU3I40ASaaFMJaLjoXGEq9Deh0WBCZDIr6Y4QRjQgQsZWXmFWvNSJm4c/39aUvdcBXau9pGhY4sZzogT/RYR1PpEWglgmsKKtLfWIc1HJvigHUTsAph+QdzHfsZa59A6FYaZ1qCwxbbDY6zge7PcK0rrWvE0FLcE/gbHaJEAVQyUVgzinKxXn7W2icEPUtYIx0EYu5hp8B2IGmok7kEB9HquGpMqDMP2NTabgoP2kBE6gTNUPfnbHVDzyfa2dOFyuNBK1mSYYJgMaBVklzb4RXCl2lJvADKiXgElFZCmDkrFjGBz9v6GwUFBaCjiUwQpgodA2WgiEtDUCptdaKwUZqElJhlmtQ40swolm9ayRQd6v6CTW6ik8iu/WbwlFCbWk+g9XBTCDuK/K8qngNFK/+z1SEQmYc1b57RXszr/qKt7hl7ROwSF7NHd1QEFMQtMhdlezIYC6x7luMu0lFJuKFGClk8ZSA/caj7S7Y+URqSSMdy5C612gPKW2N6JDCFsJz4ySnWJoHoSLQVpGeKccy7IMDE9JnL/WVL3Yq1aKMkMT/UEeYNnC7WZ6Zj4xn+CUMNO1ABHyhNRk/BYA0ynMxodpJl7hd/xdYnvLAERyZJNV7yAt2F9pBJDp9BZE1HaiBktME1RoGJpJQSh9qLFH6fz/mv2uruFM3DXcLoJb6io5xEqPALMbAKXgMLGDYOjqZ21fCasZjpoECrGnbA4vzl12z9rZAUBhhjoWLVmu2kyLApoMMwhHX4v8OmS7Xjh75p4IVg7EsZ54V0z9yG+LpNbizhShW0shloschztAYOoEwfiDZiaBW2jzbPyeHCnoq0x5QeahiiQ93fsL3LXPQqah76VoedE207xsoM8qjT5gWdHIKeiBXURm1h8842/DOLsFFYYoe6v2nrEx0zg0PDWmPpqhUFJZoRKMEJgWxYvEoHM7QNLFCmjFKeJnY/QwkSu1vowW/Z+iQvI20t034lKH5cBows1haiaChcvWkJCtNX43VjI/MWCSSxRigAQ6xzqPvbtrp15qBi6rHYYBUQO9d5MdEuMF8lRiKGX6ksIjqIVWuPvPhD2TMVdlIwH9/fsdUNOwB7y1KWsBjiEcRVqIUZV5agEqMSI0vrRiWCvNCxwJZwUNdjBhBhWdjf37XVHchx0uk5uoVwbZoqSAKz2RfMmRaSDdcHVjoOlfCmwuhk7WFGMfxEaM99wO/ZxgkECw53zBKsc/isVjrjJLXS6eURNuJlQ34gIz0OUwH3SCilE8/CwjRfL79vGyf4vqJhmBRE+bC9WS6TamZLYKJERFqDltmKPasD+YS7M7lQvUhWqNt4PgZ/YJOb9TsotYU0hgtsUSvITK+UZxI/LS+2ECHE3I11TjLU4Zqi4gVrc1cznzs/tMmdV8ScCHtgmeKjMguVKqnSTh/YRvltMSFvsetJzlpGMAJvB5Yjn+3Vaef6+0e2d1nnOlZIiAgyKUc9Fa0OoWIUw3toUz2sjbxvBRhbfVi2ZZtCH7BEL3KU/Nj6LlGYGieYr7KTYdMTpa7B+SGA1mMyl3GgKDRmVhnhR+jkJ9q10vmGbrGP4yc2uUXJ1V0VK6kHL4tJVMKPYd2iv1AyTFQ6CGI/hBtqdQAYEP1B6KeUfT7U/VNb3W0eI4F248Bu46kToINzQwnWBOp1wjIVtVmLFsIdwv+E/CboiM+iM1xz2+dntj5hBY9EP5Y1U7KBt2riWCcRZieXIGprQjCYgiHaixWJiFSDD8D/6YrUbrHf5+c2uYkeznagsODAiCa9bHHWQ1S4dpURg0laqEMUYKyd/kRd+P+QKG0Ee1Mt4pe/sNWtPDjoPswo+rgljsBKoT0RWOVMKNxuTBZcOSzEXNwSjSRqiOA1wyda5Mb6paVuBWwYxvAWpQ4gSU0xN7ESeFqbaVt/rNBtKScxjqCFalxZCFQ6B/NzYbP9ytbfuMAMWY01BjlkTkc0gChoR/Sh1LkhzMCewdjRD0le1crzU2nZaRt11XwM/trWJ9jFkCQouVyZCLBIeiyzVm533jZ13USRooo66JoRikGzaKMcnBKEEV7uXA/+xtYnmIFNTqQhVd4hfBrCCxX0OREN0VOowFhBgyrQvcKsIWmbaM1kxGsP0OKc7m9tfcK4YtlqGXo4GRq5hIgbZXjKWq2l2NxVCXUPma59i7Kjk06bMzC40DVz3/V31v5WygZsaXxtgh856yBLBGqLcGNRKG6K09LrKCCKkPgjYYeiR39DJUbSikPdv7f1SYSb3ipDHdyJJkOifHtt02j7UpoXimVDhOOG4HWyKqN+ldmCBsYE7RcxgT/Y3iVWDMNVxvts03sHP01oBVuBhT/UslwrB0CG55oTS1KUG7etFenZaEf7UPcfbXVnlRa0smJAdU0wW4aUnwkqWawu/lUUhKJLaBZGTK7Qpjae5EoTEbbzOf8nW59A9CTERrtCg5nRC2WvVFlMTdhkseGQ2MRlMH4SVjS8T50k1zqEg2/4xX+2vUtmoe6shjLB/0LV6VwWjpNSnIiqRmptE0UVpFgM2iKr7Xoly7cyRCzOqvzF1ieQljhcuaqPI+Xk4I+VnyPSDm+UXpfgYEMeKLlimKNcmKUFqxAzN60WffJXW5+E2lrcKBIPW84yyDCsdC4X5dskukq8m+3sxWQuMLiVoBE92CgWSwAknPMnf7P1CX6i1gCI9YqIAsGRTJnuypnnBD/AIlzrtmxsABYandCE0leeQ1Y6qLf53Pm7rU8w9QIsZGZI3qCliF3nyuFFWBFqY3aeRJk1IV/RUJD20C15rTybjFv053zd+YetbhEVBIFbmBmGCcFuRQNDnTHES9XhtbJR6jrFCsXgSZMhb6udeqyHc7n/aa07hr1ULkTsh4QpiFNTBGo541tZBOpMNCSzvZ4lHVRCGuxHSBTeRtbM586/bP3N8hLId22lOJlwFfQCvj18O84wgz9W3IdwIkYnfUYkNmVEooAV8wwXsYx/2+ouS7GtsI2RtuSloejdSCdDcTUJ+OgscNJrX3gthlLH0lptjsdvZvIvuMcz/2fUJ63ynoaBlApMSoxmwWuT0gq0Mw4PTZn7iLVhRWjLKHMo0/begvcDxz/X3+tsdSuXFmZ9TPBPp9swG3hTmFihdsZ2OsWNFcrqI6NHy3+DPVtmOWxFoPk/1L2LpW6CWSUcFCLGBMlirMqqbGb7YjCTsYphCZp2tjW+Z5ximTMMCdQS+CGOEPdzu2q9rW6YV3SUlmSiRMT54B4UGySegamTN7Wy77AA4UBBCPFO6fRWeW+0oBHPGOreYKs7ZSAVhMPbKlSeWnQyxnGo5LFYqxiKOJJBiIiyRXMNu147DaDIGI1dMt9rsdFSNzxMrPNjcLe1FmC8dOZ3rS3sIjZYDzBUzsyaw6jHTYnrkPBYz+qWKCY01L2rre4YAgfFpzRb0LxEBHM+ykzQ5Dp43cii1aGbtK6gBpXMqaw6hn9EZLNe7MnZzTZOdHQxwZmqolAbeAKlnlGaVO3Ow+UuOxbrHD8N/UGAUGyNUn9BS8xOWs3Xht1tckNtE5RsoaFYKusQ0oFxIKOzY8grIa2sukbrDOH/MiPoqNx2REAwUovFuf89bO+y0/xFYjnTrIHaOFnWLMaE/BT7gjbGGZZ/2yeYQ8SkI7G+UIiErONgbg/uaesT4ua8Q2x2FDUmisKhtTbNFUryCLlXKJedTlrHlWwHbfxvFVbBMVSenqHuvax1M1h1VhyFRK+gjGp0YgRhIOa/bRMdssEIh0GFTApy1tdQZ5ngNnXKZf4u97bV3WcxVASuKOOPXonws3ux3y3LTTqLI8KmJGIgEqIbMYYu6j5OFS/It91fq2o32fq7wYspFdfCGY6jUnFYHJPZdqQzHbc+Ue4IIiZ4wYRrWDnbUJuMFEfJ5jbyPnZdRcRTDjpaSXxy0GmLZoS7XOmEvDK3oWLg3TLeeU28qtQg1bZ52tLNOY7N1nHCWo59kIj+YRizDjfaVIZvJTMrEP+fagxiBEFMQwMX9eyQMa8pahY5jLdY9SAaKIgLrQUhPJT2dkMYimvQ1lmFFxAUgzVQrBWKgkCTIuriq2rjrPi+tj4hlAPhoDy6qU5EEGPJUqKTYahEJYz6pObFNRjp+M9ViTLG98rEHzbagzIfJ/vZ5iVRStYP3p6S9cZNLn+QUFoVKn8Q6xokJ2uFyJ42Qtf3rBgoE2V7SVH287r3t9UtdZozvWG584K+1M6bAiUj7kRn1xjtrGwEORQNw6iCg4t1oIQhimae22wHWOvOmPFE+tCjs13uuJbaa6B0iYE2E2EtJMTnQk3bROfzI2WAJrZBYL1a5L090NonOuJaySxlWsJoMMfhAogaR5UOKkM54D9hmojSJ2yAZ0IrQtbQWf6JuX1ykO1dyomWWwetDreu7dgEswiQpGL8WW2ISis7c1volRNnSJQuWUmakxhrd75eHmyTm7EAd4n3GOSzhJpKloaFhRWHbULoSbWm2vnbaWeLtj4xMPG34cEEH+o+xCY3MyLT+S7WW4ifWRaurILmIoTOBCVI3eJK4dWn2gVI59d4fyyk6EcMgQXvc6hVD2I14U/2yhlNl2pvrRJBoRC1zwJ7q2AWKZMPyqwlooz11TCLcQxTRfGHug+zrmm9wnza/oTq6NX6lgnI8qKcgKWsQcJEUEhJONPGeIC8GkUnWElZJ4a6D7fNeczrHo3R6wQhJAr0sVJ8sNTVSgpGDzRiDTN85qgMlFBfMd5GB+QiqNy5fXKE7V3KI5ODpozXeLpQDai8PlI6a+25qCOZmcRyepx4egGti0bjTYT4hc0i5nUuW59AYaYzFpZlpmzlSWZKI67YOZEzehS1S+SL4ZMp6FVgTLfaoBTK3S3nevDctj6p5XzN0iRizypdkBJ7tDHkLEZaADHaM2PRJPg3cSrSrIMwV7LQTEmo5v19HuucxyAkmAI/pyz2DGrocNY07T5kVsEj6MA+LLrOTEc6wh3z8lHr2owQLHLqHmnvbxRQJme4xK6CcoQdof5WhzQgD/OAuACjNNAAbRNFFokst5AgNWNzwQ+e1zovFSTJoLhaRS+Z7fKMGYaYlHKnMuVXY7J2CkPhuDIJxOErkKCErfPxfT5b3T08Kwsw1TL9y1A7nJVsQ2delThSMVxd5qAccrFyZ4uawOuuRMfli9zL57euaagihbdn2zWzGEOeCHeJvkMv4aTiA2vtD2pYCKI8RBx0owAEEPGTPF/Y9hew1Q2NCFeRyW2l29s61uFzJRrg7fK3kTZaspy1onlY+ghDztKTKB85E3Tuc1/QOgYx+hi/hObaTDngaAUt0PH4TCSCtq0X0K+Z7qaA9snltOIglXJDjf2DF7KuDX0Zi53RWaVAl00UxFbTKEd2VqGUhUJZY8JIKdcrnQ+p0MDIAmOr3w51X9gmN1MthcgGSnxexyoV11LGbjxXhjGeGR4LHQ8ZhmPOmwh0PEj7RRkDi/PcF7HOHaIKpY4bhYxfHfqHDYfIRxtC9aCkwkAnv+SNwNxjSqAIcaKwtODxqkVei4va9Anuo+Id2k5aV9rsxwSPlImHEZjpnHWiLLI1BAVrWA1bmsuJYg1itIbdvO6L2eTGAYGw6xTLSYi3dqxYbYuyQHeUyhUoDqtWOtBA+aUIXOfKmQ8JV4vKX+T/ts6dWb4NbGJC6Lx6iBFlVYKOhaaGScVSrLU21sxMLcLMdsYqi4n2pxSLdecSVn2CTYDTilJDVh0473SGJpPh2SImplXXBwxmDB5sIl3Qoe28mU46h/HifpJL2u1Blr9CyTUV38fdwTkjqE6oVbQKbjUeAitorJNITJlW2Y51JLhT7uSF7XMpKw+BHtWOUeLy2HypjuDDDDTYg6L8a2XOFZNeJ3CoFV4JlIWC4RgXom/mftqlbXUHykFApFURLsZ2o1ygifKPifslJojbHBfaHKlM9aXSdtYsl5m2IfBt7qcFtrlTiCDEtGoL+X9Kg1voZzrNk4tTx4xNZTOyaMfaD9DHCtCg6uElu8U+vNBWN2ugUsBjFuKZ8kJ1XwZ2YY9RpZ0y2hLZK9kAtGeNwSUibnaJgc7bouaGuiNb3UTLOzwFAmp4p3AaRANgNHN6IdJ+ONhSDUlF7IlgxkrdAP+oqz+Ukb6ej8HYqmN5da1iFtrMA5UUBUp/o9B2XGAqYtjDavAGcUwIxGAjYuFhIrWz/TqLc/+JrW7tUlPPEmNpEuUraJQShnmu6FY/SwSIHY9RlyeoXBiWAo4aky0k6Nku7MHUWjedkre48phuLDfELbBHdNpKDDN+JoE6xpKy7BXaBaAN4DwkZ7nutOF0qDuzzUvWLkyvlmFN4F1XvmgVhtjUyW6F6TGrUDd1DvutvblMmKxSfLbsCZou7jvKbXXDo4WslJg52iQNe6IjU/g+jBPGAyqQt0fAV3muCURmihlBVBJ/1KqUze3BwtYnMWQj7BwhaLzLbrY9nrZW2hzC6qtDQjqKkeBJ6ZAjkVHClkQeW3EAxWIPa2nlZmDpWthMzOoERUWljXaJ4LFJO+ExzZIrwGJmalWAPw/7yVJUzAIz8/F9GStfFev4FQQMxA/jRYfpui7Gh82KWAfGohK7lmWOt9t2hW5gIWpE+JX3DtM/H4OXtc75gFgrDm6qU0Y6kc6Cq+QFPSEL5aTVoVrCg0pHja2C98o0VU7WOsLSX8S8LmcdJzrRnmp3H84woa20jpXHq9feuYBwOgtHVCg7BzqS0AO6BC9LabcxbJvFenl5W91i4wiQ6DYMpSFjXVdWslInr7teaSUJwmSSHvYJ5xm1gFXEuGQaE1mfz50rWNedAlUVac9HqaswUFTEG3BJmCiQTCX0mE6lsNBjeIqoxnzgbaDX4QyrxbnoK1rHd6IObJVCFKtGVhlvSMFBnWbqtONR26qJ/3SzC7fwLvDZGPFFDJm1yAt6lNVmo1JlU2K605fKqqRtmbXy4Yk/V7avWHETRhOGHfLmOcQPHi8RwWCRP/ZKtnWH2CFkfB/rOgHsbgjqUvn3Gcq4k622QKIOUeyzHE698iphfrI4646vfjF3rmy1IbDzGH0QJTkRQfzVaNZaCg6+dt+HygWA26DQNs3B6kYBo4Uabc2Yr/NXservGMWqq7qUHbTByOqKDn5KiUO0O1nnXCEf6wZ+pZ7leBUPETOUCO/FC57taKvPrbEWoOiVKYi5DsWubCsMkzBn4Si0wxIyIdQ1Gvg7PaGxTt4XS2nULHifY6z8oLJ0wQUQWu50pKYItHtS+977hhUm0pUKOgaoPChE0WfJ3Ok57NAZwzDUfVXrelkpvRO8ESqWLqTxJRpEaXzga4gKsiIpcFY1StioSBUcSDbLmQIFnM/H97FW7hFPAIK6IQLSYTFBGSvDj06MMXXQBZkuJpjlcE5j7RvMtMGoRh8q9L1YG65mkxuXK1Dyq1TRilR7B2LdTIcrKD0FEauG4fcQ5oAcz5R5j0hkongYfsO8T65u9Um0DynXHsJcWTkCXe2WKld3FmOcKLlPoxPeCkArywcrMPpbiYlZ/vty/i6Ps/qA2qE6S3kbKkUt0Urdy4TB0KWZ9rV2YmACaZg6rhQbVSqqRqklZ3Heoe5rWOqOdVCBrpUHmWBi67ok4gu4loRNEumjRHuvcmkVVicoQ92Eot3x9JVh+1zTarOFrJSZ8p/iMcFVYwEVzBm4dlbJPphFiAld4Hi2ysLcyVBiMcm0Pwqieaj7eFvdASFa4nWVvBtlCIyhrugTLEEmZq8YFQEAAq344XBlhM9r0WShkrVGRi7Ja9neJVSOsqagomIdRJdz3OtGQ207jXW52mwjFYFRPNig05nuYJbGhAfTwPl6eYKdH9RVKqgIpcTH9WOM9fxpUursWAUxIEsfPwgyk2hdq202s2NKrCepkd/+2la/gcBZr2B0p3CLTqQoMZCO1sS6SI1ZjmWhc2W8dSKLLJtK21TqDgeWiHmM8TrWuaNU+WEB8VcSOda05E/lQCiLCxaXeDi8CdaNOAt1+A0di5eFIx0rB99Q94lWG0JpYGod8qBepVuNpF8C7T6MUVU6rIuDw4RBl1UVXn+klAONUvUE0WJNu66tTzrFcgrlRyS0VcNy0we4elmp8wzKdKTsWPA+YikwltGVoQKzKE/m8cJPO8lqs7GkZXA60BnaVo+rCyNKRLiIFIcvRcrmhVY8nQUiuITKVLpDXYnH4Jn7adezzkvlIoPljpXrALeHgBnVNIUuy8qgC5RgM9ZZ3VAnD3jzSaTsLrqdTHuEhrqvb+sT/F4li0qxHbChlM9NKWnz2WYLGA3lIqVrxXSyorIEReJNMJJi7ZFcnM0/2bo2tJH+lh5RpAw9QtwIrUeUsYsw8Fk9IevhOQiQ9vLegtlWvzKY3b25yLd+A1t/V8pSKiM70m5VZRqE9VWaWp1gJAxbswzpIg4ddj0zk6UIcu05J1bdz/X3Da3rTohNM0vz2OIh42yLOe4YGwTndNoj1O4A+LdIKWnpiF5xpNk9QoQ0F2PwRlZOqVQ6/1z7Y0KF5pQvA8q/CSMMKSwJiCVtOtV9Ww2RQsbnLLFiQzBdO6qHum9sk7tU9hP+GLYHzQKjriumYKtgZatQhH7ZtiJ8tQ1AuUNQs7q8kUAYbOhinb+JdXz3yjCk1TXF94DNVT7NmDUe7dTqwHmmqVqz6ih1ZaH9TKVuS+CtEoiYj+9TrLZPq4MeoXQdszpOIE9Yhkt0XqqLVVol5oUYxAWHX1fODwwUPAgdXcDLndsQN7XybBDrRLsyXbOFgQJzp/x/RaMLK1F9BYuOCKxAiSZ0OK3UZT0MLLoO/3j+Lm9mtTVxRnRZpPbW4TkpbJwzKnSzlGgMotO1TmWg5HPdp4FHoq11ukaSsbq4L+Pmtrob7eHH0IYylWfZldhL0NLSBbhleENZJDqYF3LmXWH43uhgNFs620s91F3Z+htHWhmRCdcQo9c+HyWIzpUSsNPFutg72qjXKq900mCU54XuicMrZb3DGBjqrm11s4LBdlV1RciygNwh7M1aRNOLRpkq5SPEtZL3otKINlTKC47S7QjciZUY6m4c9qAyNmNrEvyCNE4L7cUmzkKomSFJOAK7ShfTRoEugSp0Vw62Ciqgw5aej8HWWreCCNVsf5luCiJ4Xuv4mM67VrprQnmwZKlpX3WFM8UiGRJdRzliNy72EnW2Oa/s6rIgdJ1wrAS4oVI6zu6Qo3pijrqGoiF0EARK9NfNUvfHkOPajNfP53xvtSEgiXrsTaJbTCNdaaHd3cUsMyPjAPc6UTpJ7S9iDle8dB0C1t4frIqFT3ILK9cbE2XUXUby7rQFRfZCiaHdBbpfkJgOri3LOusaPnYtQ1SZs9oGqx8Wb6j7lnauV6YfY4MvuWhopb1TEhztRWLQQYR3SvlWaB3VPYTKPk6HYCkqddtQ962sfUKceBY9YpXR1hYCgdo3pDGNLlVi2moW34l0FEbhNm3Sw6FiOEIUzuu+tbVPuhrbmGBqLX6rUD42YiCsYAGmIrRUhgOqe3QgrSE2u1kKOu2VUFb+esF/38a6FqfQrQ0uO6FdTMom0fWDGPYsa4QWNKC1QGe1ziBEyrQXME47eSdEfxf2yam2unVxM2SRaEzlpyM+n+Z4Zso9QagunoUFy9lOR1UcotEyJXKDqumVq32o+7ZWLkx7m7DVCm3/CJtgtscPpaekKEpdA0mgrEzaLRJoK4auH4b4YJigwdo5z3Y7W3+zJir56Zl5HnV6p4F9lnOWNb3uOqowE1vtjxexgQrgNda56HzMu25h259m6xMsEAziThuFme4SSNl3WDnpVV4o05z+CAssogzfUFdRsfZoPxfUSrw4V3d7K+8DrR70sy2ECaO6VpQ8ZnWOdMNomyXK68GMYsQw8kSc6A4/XVLRirmZz/k7WG3kcnazr2Kh+KoEMIhl10qrxXJQZPHsMtNaN7kXuu5Gt2+h3qHhc5HBxZyvOt2qq0Kmmm46k/7XuSVWRazZSFerJDURglwqEM5doZdUEcAy01Y5nAodfh/qPsNqnyiRKWwf5LqUc6Rba2rt0hEREfTaB43lxhDqlXi3U7oZVKKSCmQo+bnfcEcrP5gSuWx0gZSyMujyaOgBbSko0bkJo08Pgj5WkoRZGkLticbGY45Bvs3f5Z2scqPoGFtKq8R01vUkysxPh+g6YznLxSyDACMbj0h72DGMGOU1qpxlZb4W39lWt1xVZbuLlEdENxM1/L9u7Yt1M5mS7eTQvcoLEerqHWJfSvlICG7WlHkM5i5WH7CP00SpdAll1VHdoVt0qbNsV2xBjR8tPyxLkbZxap3H/om07QXmOZ+Pk7tax0muu7rwhRUPLtGnOMiZMplq3leQVwRJGMdhpRvW0GthrrOROJ6RsuXM7aq7WbkCZYmsi4LIOX8cYQbpoA7vUu5TgUszy6iNraNTXwriNTppiEvCcIkXvM/dbXXrulxdQ01f6HI5BRE7bS3DKtNp8VgsScSsgn+rQpHHFcG6RIkh1TvzMXgPKzeTKS95q+2BynTA1M5TCAddh9XowiTsAIK+me5Y0Q5c3ZuRK12zKM6knK+X97RyeIVojRKthjrkxdMGwmo97ywrtdMOgoyxzuqApaLbp7E14KpKbA38wsU53XvZ5o72g8GFMapnSf+7SKkew9mRIEJ2YsYxoIjyMAsYSAWLmZJg6vp05RNb5P+2rsXaiaCcxcnsOrqYCSSvVQfYoXaIyWvLbK/jCGiwSvemN8rXjCWErqznc+c+Vh0LV1HpIHcsiqMrRfoRlyp1KVarYJpudYC30RZ4rTtVqWzuur1Ab2rOzWy1rjtQFvB2uDKKjGSREiqUtZLgEERjaUx1h2YgV1xxwFk6NSV81C46OLn5vLyvbV7qVh/YW6hYwqkQ23AQtW7HSpUljcGcV0rGl8EnZNod1+iCi15Ju3tlRZyvl/ez2t+oE+WIzOtILlqhg4yVCDUdJpMHUkLgKyc3TnAHZ8V4jGfJHnVT6yIOeH/rOl/pbDjhfaXuSKCiyk5HlmfJ9MsIr4zANiwCKrhqE/HU/JMoHbQZ6/9iv88DbHXnM9dDtFZVKzWYUmrpdu9YBzhxhHm1KV5coTtPw4KICVZ/rDw8eREa9zE+0GqzKTltlopQgu3VDhzIHR27CHScDHcv0J26aaFdZzID81neL94r0YN08S4fZPUbtI8ooMPxAiBvI+21Uj4ShOTtsfQr56Wotlg7jdBbzSwZCo+kvQve/sFWjqNFxen+Cig75bOIWblQubF8cF04lSuxLlRgW8r5hAyb5dOHndCunEXO0YdY+7vX5XyEyImQQUWXzJhA+zQ65YPSHdxKpRifeXt2rOtt5HnlOlqrZFnzPnmolY9l8WVKYudA+uq2elYU5QWGs89FFUalTiwqyIlRD1elRGGzu0winbyZj++HWedOrPRorLFYbHLXidnoODetJqDDqqgtHfjkNKvQ3Q2BRk2rVPuK7S14n4dbx4l2IfVMkEgZI5MzT+cQyp7RrTl9kOnUKCMVS1eXCuGYsK4qkQtxk8X+70fY6i6VsqdMZ9ylNohVmom6PUTXjUY4l7yRvtCVmi3feRwuhO52on2YWfPx/Uhb3VEchtqkzVpe6k54mORacdESU18nerRbjqpnW8ISpq9SCylNBIZ7Wyz04KPsHF6uy+dRWbwrIroQs1DqvARttK90Ue/s8FoV6B5aHJFMx21Zz5QmKl2c2Xu0lYeIZsn9dU8mnB+LVkT8o5vtWqV/8UEIemE/FborQffY6cLDSgcbq9llpkPdj7Hag3Css9wmTMpcQQx8+1kQvtFGNN1bGiols86s6XKmThkglaiojWfO91D3Y21yw5VpMyLeSK3tfcRbY/iNWtufu0h7cSEoQh35VyY5yGNtpIXWrhWViha2z+Os9mCAl4NXidzKsKAgLCH4INKZKCXag+uJ5aYlOnJI2AiruVe6C8K1Ohw/1P14W59A+aG2sWLRoRnB6IQ5gZKBgeD/tEcsJfiKTa/r4jNt3yw63bkrlhNDb742PMEmdzBTmCgPJQ5hwCrRDP0uCyFUIEqJWjpWNZ2p18RCxeqEdqDNedXi3qAn2uqemahMk1ZZ33QsXsc7Z6mZdN5B10ZqoddCgOWitulAo9Ja6TKEaj6+n2TlHqE4Cl2rgvWIL1DgLmhLgows9EWhbexdpIgAVkQDsQLdh/ZRpp+sMvbHPtk2d3SrbaSL9uA3sefzDiWhYwG82n52oZ+ypMLXYhsyK2feIHGktGSlL4y8LU+x1A11iQ/K1Ml1VSchYu3V150FyhtP40UhxNjEsMYo207MBnGmUFeBowEWce6n2voErVRqKxhR2kr3n7SzLM5E1nAmsUp6bY+voa7KMNaiCbeKjaI7EBji0SIP1NOsvE+vHTOddnnG2s0cK5WAzggWCm32yliTK5mOktH32lnJkkecQ9ESHU4f6n663Y5VQiUsSG2oZj1MCD+xJPbSjbh6cOhwMLlSFuiQRaOLXrVDL9E+USijoe5nWH2pPNHRPthKYg7KzhGVXa8jxbrjGqazF4XMjEWzK41SrhQEGPvYj7jjixwlz7Su8xgLaOVSOxAxd9CCvMRcFw5ixIbKKttp3je6Vy7T6X16Hsa+Y2pqE+dQ97OsvE+tkA3xJsjbDE+ebsRbKBL6NteJDCzyWMl3Es2eIiB+BO8Je1uLQFzE6p5t9YtF8rdiMpAf2pxQtHL4YRCKgCjp8KbSTv+cdSlT0lvdm6ctMCI/6zlX8ByrHmx18SyRFaVeZH7qije5J7hsylOkDbhYdFXQNZVuvGwJWxMq6YmEo2sXeRaea/Vdpdq0jQX9qrs8KilYmSy6G6/TsdmeyGtcKSMWKweWi84M5moG8dH5GHye7V3qjqFMudOrQAF0XSRJ5CieRauUtD3TKR3txRFLhfZreulzeL0wMc+7Pt9qQ+AJsEoRm0M+XakV6lAM70B7WKGy6kKvTLvxA53ohW1h4cETypVqbTEvX2Dtk0552vtZIhjlvGaM1MrmWmhDX6NNjyFrm67kwKtUrlOdZU5mu6+092Oo+4VWn5sAObOurUM5rXGfBWmtG17lFQSKH+OvVYWygRTKSQtXKS1Q4xonxKgW+b/t4zurQt2TmCtBHawLnkehXH7oacZno6P7jY6I6v6SRtcFs1gQD0epyaEe6n6xlWdDf2Ty/ZnouP80mgUXJgDKLde1atrIjtEFq8SrhYDt8H+iRrfY6BzOXO6XWPskTludTiIsVYjMwajRXX6M6jxgEOdKUBfrVgrcWmkYXQYiLijSTdILPfhSqx0bMqMJUWIp6cgr/4n4r+7Y0lYi7epXxnHt/G5QuYnufdU+t1Yb+PrF2c6XWf15GWVKphX0s/1KonNyZgW0EtERJMXXmW1XACIeErtC12mLcSY4OLeRX27rE6ZeU8p1UrIFna2O6kaaJJttu0fkDOtWhO/smmdt8JMdFMO317r7eKj7FVY7ligOfFyoOxRwGBQs0j7wvtB+nBlzTxRWae1rJSBVHFz59oj6aCf0InfnK612bMP046WEOj6hqyoaHCCC79hBs0xpimlgaypEHzDmqpmPCBg/I6sX3Pqr7P4lzKDGF5Y975RwVqW90hWaQCniS9261SsfdxrPjhLoujrsNgzrrAkW3MyrrbYP+hlvRMmgWex7nUWDPYEGwjLMFOrVNZeR8ri05YxST1ggICeY74lx98lrrHLLnYSWzkRLs2oFuJipEj7hSyojUZgqhXfF8qRraLB2dIliWIqOxzWd+5evtepBxM1n95gpbjTbtM7yjFmpewRgLnHMEJulIeuV77HBNGQm1bqfXknRhrpfZ3+XhTYDJqWCIJAFmfLutNKtAb6QLpfBXuyqXPeroAsIcBQi3mgYcepFPO31VntQtHbRpCV/Ax2qbCSsbQXqg8DJbB7KlJN/rPsPKyKdOjxGACvVjuJF/m/ruiNWtdOepF43VoWB7hWMsbq1YUH3nTG7tWspiBQk1KWu8AepDqUSwS/mevCNVvs7aJVyEtVTEsnE74Uh1UjBrtLWxDjKsLV0kiGHW2FI51hicFt1K6W82A/xJquOrVjN6QptAmAxYZBBKOtKnj6DpsLYwjkrqKjTHI2h4HnVhQhLHMZokcP4zVaOg7mHniPMXc7yaVUK8uvAJIo3zrUWZOpa5QDRYS+YAvSiojMBdt1inLzFVrfORUeJjkiwrsCsF9r8rjMCyioHE4GN08DXEBTQ3gVlYYVzUy6oTpd2zOM7b7XOS1E6rE66e7bSnd5KXUyV2Piz7fFK2IRGTNEwMks0/7FAWdBY/Qw/7W22umtqYzZDsRK2hZJgncephnsV9VvObqeFRmnVPqwG7E5e7Gy112Xni9jR263cTKXjffCgkI26qFzpcGCrKsWHYA9m26ZRAzrEAycMa1VBP2D2E2gkqD5/l++w2oNKcwZnorPajY6yx3g5ePC6hJ5lJ9P+QehIfPtCdqGycYS63QU7PSB4MNT9TtvcCauw6hXqb2WwR2LooCJkBsaQtC1di1+oHDRhoP0BrMMta56OsqDwF2fc32Vd0wJYmdkluYXS7tXojEqXXmuNhpTSKetCOXEYE9ixqU400iFBrFA0NvlQ97ut/g7zMNBhOu0TjHTKgxcb6h4yVjC8FO3FzrBMlLhPVw93yoamRGQxIe+FXfUeW92EWWvtlMtmW0NoNo6SciZhp/SN2F3GCa85L5RGDvJKJ3h73Xqic1aL/T7vtb5LeH64EtgZ5l2qC6wKJW4hTNRkUKNQvhjQmlss/7pRCgYKszzUJXlVsTiz9z7rvGQw1QoY4cFH2pQwO8+T6QZZLb61LtptlGwKG1PKDA+USBPvkbBptthn+n6b3L2SGuW6U4b5h/Xb6tDfbMO96IBGbxRWRVYPLJ9C1rUuiUCFiZjo5/7lB2z9jeWla9zphkY3z/JCEx0lIZykVBr9jLMqY2Wlnl013M0uuapZgxijyYIL+6DVvyRGVFe8wkS551k7GWzwGxApWAiJrmXCzY6jOtHwhz7MxIvpbLr2aueL/N+2urFW07JVnkLlOdeRw0BMCRE1HcwVSaorenWSR1nfqizQ5be50lHrKOlcn3zY9i6hpgutBzqxQ1/jOOJZVloAdIOD7MI2KnplHi6Us1LKgNgBT9Wu7WTOI3/E2t8y0xlhDHC4iFLXY1WEhVM8Yyy+uFGcDYNTNLZu8mSAJrWyn6HCAzP/t22cRJkou1Z3cOi2sySKGFkFYyfSTXaQyDyt1sFJXMBUygRLjFgHxEKm++KHuj9mHd+6WKPWpe+6FzCYxeAgsFjutXtBKfvhsljTlEoHtaJopm4KZXpGLaGNoe6PW7kZKuQNpi0NhttSgg+lQULltsrdNrutu5jdqpbrzHuF+9oqHQpNUP71oe5P2OSGV4NCZgFIMnE7RIJhf0odFmI9YAVQFhDFBzHJtcFD97p2cgCVb6lf5Nr7pHWd192NBD50+Ed73QPdg4nzpjCV9gAo3ErNsQ6OaW+vtm5CcugiJ+bRXO5PWcdgq2OruqKPOJFSc+M2igIra0WdI2JbOWwE7ah1jD7LlOxKd98QosGnmuvYT1vnJexdpASJrRLLlJAxaQ3vHWC4VzK9UVBKOlrKc1WmvUTpcnQxaK5On3N4n7HysSXOQR7p5jIszEKp3fAzlRi/VExNdwRjAyil2CxTbax9E3BstbRNubjH5rPW9RJiBuVP7+JK49+JjdLIgZNSNj0o+1bBGGKO2rSAPaEMZJUYD0zzcC7356w2csGKw0IQY3PGTD+CgLXOYeiik0pna3TtL34cpEOI1YxxIbe2x0kLdOnRUPfnbXWLCuxjbBId+K90Zlzbm3R2M8gj3VGXKy8zmoopFegso0LIGBP4WHTX3B78gpU/SURsdcoMn7IqwrQp9xWkOO84JKCpoHmsizR0bFXcKbYSrAphR92NNR/fX7T6Un0vd5UIPHOPVYg4DpyH3q/uTdVc1e1qSsIHH44BhkeMgcvvebfhwk/7kpU/USYBtJuCEyhUNECkxFKFtmyhvuN8RhPyAN1LkWijHCpYCTF5K0zToe4vW/sbSjrQxioCx7o7DmZ6dvq6r3ULa5DDwc0S9NLnsOwZZBw6S/s6WKiCRb6Zr1j7G0+qKJS2D3JGeUMI2+mQibZspDX+Dh0RVrPEXzWzFwqs0B6eXvf1Nov4zlet3Eyus1KEeaB+6ANtbcHRmd3KgVuZ8yOcIdaPBFIPtaPN28qPrNuz6L55f3/N7s/Xuq+gnAVviKxkrGAysFod9uwhHrSVHeeSUdcr970SAbVKDwP10S7yQH3dOucLZRfWgU3dK0j7mcyRbmoroO0bhj4vEEdf539LXZgm8l1nStAqkPdzO/YbVr84UcIXLLtSXOiMq5I304iX1fZE1hYRH5l2o+EzEOJh8GMwad9jttCD37TKTbwf91zbyzIlOcqVMx6CBwUIuYHNQNCFwa7geUpdtShI6FmlVNTlIkPd37LVXZ251THW3pZYBFij87eZrmzQyW0s5qjWNpo8mh0Ig3aX80IIEOu3WORC+La9v7M+wh+GJSa2qH2bidgBHe9uQww4TdhaObF0WhAVpWvFiJYkSkZGi4a6v2Mbg7GyW892nMhkiHTzOx6Z3mmtU7DyP4gvYnMzewp5zyKHiJ6WjNpmkV/zu1YOr9ON4YTzdcRf4ZtE1wCgZEWV6v6tCvYHZ6tCl3dnHm3AQtJFBnCci7zl37P6DUqoUON7oO11s0/FGhnWMUM+j2YBUO1dTbVJHUMNjy1WmqgeE5EoWLfIk/N969xRNjrdxwHFSyitVEwNnwArjroZLswtXeEZaS9bpDtaic+wKhFBZfVe7In/gaXuWPf6YHuESkuVYWr32taj05ypbgnF8+lxj1mMcfaZ79C7DKRIhJn2cy/8nR9auUd0M25ghU6LOt0ryl/K3ERf64hdLU6J2GytzIHQB7ruIemVDl0BpGD+Ln9k65MyQCaZKErn3LFYKl9DJucam1hXl8KVwgLzswrnTzd1M+RLnbKoCULO18sfW33XHnIDQxUrPtKJOlYbuibuZ7uSsYsDrfE44MRnsxxDiD6O0LRooRznf+6T/MTOzRCL063R2p9IqCzTVpNIe7wV5U2Uhl9neFl44ZN57coB1cozaSPZ/UPdP7WNwVo7UctUd/gRDtItAYrBtMo5WiedLqpVCkU4Ktg+or04mCwU+Jmza00XZ/Z+ZtffRBR1lSPTjzGIV4WbwxifGUJQ9HiEWanzmMoFR7Q9FDUIvCGSni/yiPzcqqsqJQbEElamIMwyHQEmjK6c7URCMCFoVamEpgGamyUo07a6Tru5GADRfJz8wtonSm6bztxhHU9RsLuWoYnOgkVQXiNIA5RgB9GsjVI5LAIaiDBbQChzPr5/aXuXSQpN2RB5Rgfp8BE6OxBryRssIYFDBRXx+lCOGI2ZovI5Ha0Lj7F5F/G0X1m5gghrPieGoHRDaSWioxZHQqxRWd3Rq2WmAwQ5UdGu0MFEXZAk9h7OYpGD/tfWPtGdVxgGge63RIdANBS8u0oHAuFfIH50IXeP+aOgAX5Ir0vcUyXOY9zM9clvbHVHOplcdNroR0MTxXdY1IlkdhjLEJm9KHG8QP0r0UULjPGKQZ41CSGCudy/tc7LaHbcgBiDiHAZQFgkOB1KLo7SbRVLSnT8T25nHijBR5PpIhplgg7n/f07qz5h8M0uIlK6eFR/1okeVjoRIuq9LkpW/uJYCXSSTvvTeBNM+lR50MrF/VK/t9Yd6krhWHc9saD0SurPa4QgLLQFVykAsjOPRymdsw7VlXDCszskiAgt+JM/WDlTiSAPEFup1vakVucXWWdYEjLdaJPo5HahXFvRLGVdq0x8uvMCSmVxN8Qfbf0Ns4OdgR1f62ofWPVe9wQQZoYZkJmlQxk6sKLYZpXrFkUl5esVmsEIn/tSf7KuDTDZ0IEaUMqbGipoPktenyrfVq3r0TtdU0V8Vns94MNgnVlPYcgaQ+4/W33XmQcIvx0pqqadREWmeAUqAA2rROzoDlHhWT1bn5SBMI+LloBmYfCDf7H1N4MtgbRKdBfvjJFR7hp0SKf8JpWutm+VAxfWnvGhrK4M2UxpoHDv02auB/9qkzvodJidoA6WhPI4YERiPpxJCLJ8drrzsqfb8ECTJIq1MRZ7AL481qVEc/v7b3a7SqGgKtKNyr2iy4XuUSCur0NaxJIj3bCkvFzENuPZVhTiBLqyhGGEch7q/ruV96lq4nGhcoZBFTP/OkIBCqOzHodKH406ZTGGbmdgFLOkcKU8AfwAkcFD3f+w6ZOymfH9mU5gQScq3UET6UpNwkez1MhKsAZbFeqkYKZN86kuVCM+SphxweH90yY3i4z2f7KG6GaMWS6vWDdQEoXQqZgOjx4PS3nztdk8VsAfeq0loJIqmD7U/S/rnGdu6BCqttLCNcSBLm/nrdWs5MowoVM7CtEwWHp5I9p2EuuyjkLpcufj+9/WtTjWbRx4dXhkuoQe6XVVQKo4KP+f6kQcbgNOAv2BNSQyPprtU5JNPdeDK7tY6qaZmHuZDs1CduuonLYN6HBopwmFk1JrZxIzMxP7xLDRthpdYxThTCzyf1vq1l4LOTDKwwjNEyile9IrKiLnI9URkzRQdg646hyntRQJpjwauEKJcdfjLja541LJ9nS+bXaRRIkNWOKNEREUfYUmh5bAiMG0zbRHr9UOr0SXMeIPJAvbZ72t7g7+WbdIMcy0Mwu+FbZe17LEimMq8lpEuhdP53k13QM8NUKxNVYBVta87g22Pgk7PHXcNBYrlgMoMe2GVz4Y3YnVK/k5c4T+YmFFyUDO1olSjmAj4oku4sUbbXXrdE6p4af+JRACLSWBmqhIal35PUs0Wmny4ljiQtMp6J/ZBa26k2aoe1dbn2jrXaIbTrR3Iscd1DbKUPeZKdSikBxqdXaDU9Lj3RIRRwnDy7CC0Glzm203m9ypbhPD89Kl8hiF8ldTMYTK5lHr7mHdzVKIGUtEs8GQZ1Gu65HhuKBkh7p3t9SNHTBL7aG3xkLISoP6KxSla/pA96CL8tT1sthTsulL4j06F5JqQ2O7yD2xh01ueAE8KZhHzM0zJwoLQ9IrG/csizbubKhrmnS6VVcd58qqKTeA1xsuzpDtaetvVJ72pTMe4rRG2Fr7d0vl4Gh0G4WuKFM6V4xBnDTUU0s/6c4vpVwpF/sh9rLJjaAE4bCzq0QZsqEYiA0Fysija58q5aXtRXigcCNlzZldOkmkCRJK96MNde9t62+lDSaoi79Kv87ORhCfYo7DoDC4K2W81L3tKO9KCyXslfLw4fwnNW74nGfbZJObZUb3/lUzgwFWFDGhpMNZqkHeWadELf0suV+njWGE32ALdKIeHZkscqLvY53zna7SDbXvKdS+d51ildnZ95FmUqht5njCORabrk6GHcxnN0AlrCfZ4uzEZuu7hFlUwji0v3ZFKEcolTfYl7VWGRxXxQva2e2E4SwcrXuTlZe90XWLQ91bbHUXSgSYaJ+ZEujXDUx6OFPZ8IRtpO1x2sCEniLexVvWZY1wTwrrNbqIYah7X9u7VKbfqpBrptOJSszd6N5cJazpdQERC72updUhPVZOjLq8VxbWmukGYTCfl/vZ6ibMUGDa1bqFNpolmAmVsbvU1e6t7paUY8IU6rXgRTpJILK3Umpp7dIZ6t7foavgoquet8+CTjxLmwE034m55MqHkunut3bGguPUsTjoIgrWauVaWfTJAba6FXnXhUO6xBATomsr3dEQs0rQ6SwX6O441p6gKkN1SfHAE+otKkFWMx/fB9rq5k91dTAko/Lcgk/xiHNlhYE/0pZF3iPBNZ6iiJT6qRXFrCvRla5xqPsgq9yVdJ8orj6ZbfRkrLN8KscOwzfXhQCZduJUOCS1zIGshTyBqMC+7xZ21cFWHVsp/k5zmaFEL/BTWXqrmerDk5Qri5UFy6uLO3FAayh2WBb5opgGi3uxDrHVLUI315kORQGI2NT4ObCv2HKwpVgU2loo9zWf3f7BCqcbtFrtp8W+W+zJOdRWt+46gCIuKrwnXRTZdSV6Wbd3YRERcS51iA5OVneEyRGOdImT9nLkurFnblcdZp3zysQKScJcK+X7xbqGBycKJaK7xLHCq9kM0q0QmYJ/gRSntnJkNG9e9+G2uonB6EDTmUaBpjHmdqeTlkoSj7ZFlcq91q1cOmgv3ytTfgFdN5wvxskRtj4pCB4qsUDEa1M6Sh0QxU9KCoL0Ic4aM4VIPXYl64Z2uShBqPb3h9qxuYi7nss652FHtK9Oib3kO2EX6CwagRCmCQ2hkxkOIatkzWBqIqjHXKNR2S6qxf3c57b1CaYutkmlnJHaphYUs0zjjL9WqZAL5iPhQCKvOkJO7BcfVHHwKlDyzH7hA57HuqZFaGICZUoS28falawzA9oznLDEY29jweQziq3FKK1kN+C9nHmLdLLgfY602hBiVjPtOoKMr5RASGawLE9tNUt5zWi+kInKSjk7SpfNToCilkVbz9f589rkRkWlSo/Pqg43DWsETa8r4ZU4n5hDIH2VKMUI1jR0DcpGCUwwA3SvTTiv+3y2/u6VjRuTQ5S37lJQ3g2F47X3Hh2imwaUrQOOWRcDEJ9SbshUd87oCtH5GDy/VW4cOSaZYkxxKM1EgFxCKg0ySoVuJyQ1S0Sv06jKp0MwCFeo0z6aRU6vC9j6m0WdSpO8RAGlytOtTHLK5BonEBza8DfbTBQpI18pa7NOtR8K9pb1epE7/4I2ueuu1DED2d2JuJOUUab0WjUMXabj4lknql4nkJuk0FZ1QoXKUsiLbRZ3KV3IOi+x/NJaN98oIKhG0Jn4OaWSbxSptjR3sgPrJkM/ph2xwbQJdAtQylSYy31hW58kLYJj5XSwPpUWXN30if+O7Y5gHVJDCsL9QlFq16h2Y83GIOqwzhZz/iLWtZgolDJNJEQ7S3jYqNNZNJnBmbLs0UnM7RyGGX1S5WJlE5j4cnYjQ7uQ+6I2uTOl4i5mRkOtY8yKgBEJIUDFTA20XzVTgvpKJzYCQgQodgyIRLmOO+MO1ovZ5NatOzoMCHmHLYVfz/sPlfNe1/+lxL577UjrZEkzx0pdzMgKqgyFDNd2kf/b9i61f17GfcsSGGHMErdoOjiTVnxnpcSGhE2Uhky3r/TKPa8ktlozc4b+vO5L2OROdZmSgmit7llnCjK8U50ZYKzpzdF03ZqWYM5Vypif6GrWMETftIyZua66pK2/oXp7Xouy/8ZEDvFSeXMZFQTBmQfZCc4EeT1LtNzp6CoUOM42yzydstjvcylbnySzy6EbZdFSDmhdKACNHLQz86bSpkjl1o86uAOdYcJ4ZMkLShHLiTEvL23tE7iHWqeLet35CZHURaKXoM5rkTHEQuj+XlmU5V2WuiNeCbQDbYCLF2eDAlvd2qahPSKdDmsms3hzM7sLE7IrUz7KRnnWMYmIfuGwxglyw53GuharWZzLCK22/cyZ0aWcQaODHNAwuuEbl6fDcdPlUigmHFxeIK4obBluQK0d2qmIwnndkdXnbpV3rNKt8xrLxF7ozkI7MnW4OpYBQGQOKh8F1kSza1XhOHNd8ILZP7ftY6uOLWMsx065J6JUSTMJ0DdwnMTKdWQMFyKYHW5SglSeI7sn0A3kcJVEIuf9ndh5nwh3ONaFKTqYjEmZhTAq2uoY6eKhSsd2RS3ruiNd0FNBWGGAhqLxF+t8arXZ5JuzrEdyMjGYIQ+wVEOERY3ik6hFDO5U+S1gtIhJFzI3q1zp4RZxqczKszG/dWc7rLGywkJ8xzO3HaYhVlrhXvk8O+IjLZWLSoU1iAl66jgRLMVQd26rO1dmUmVHZFSnuvoq1D3npS7GgubRVY1QxoQc0lrXXhfaQERkTJnmlAty7s8X9nWH2BOzMCGUUyinh7Lt56U4mKYVT4V2xNRBQaLRaYUupkTja4M1PMfcZiutdhVkb6OrStNEZ2/TJikJI4mgIvKTaF4TnKlC3Q2W4JtXuv810mQLdSx53t+XsdVdakMCrw9pYjHa+DMBEUtYmlrWZFMpg6SOnmu3AWpKV1Zp263uGy4X9sllrf6OLm1I0Mu6toqYV9ogu/LuMYaVTh9Gn36CzipmOoQ4AR44ZB4ud2Ts/76cVQ8q05ZunFaiTWwpRrB4Dc0LwjK8MU16XfLDUNHVOEqWB+fZKDE/K8dQ9+Wtdet8dhhFOiTQ69I6+GcYOpiNVER9wXvuZhtwdRip0XlaRTBlAuHnhvN5eQVb3QT5tE4plwxsZctLLftc6ThaHSdRtAp7X+c7mP2pshnC5nU4h4VieIt9Sle06ipIdG1m01UBUDH4R1LSROKYkyUhWeJDvcgjpZuc+SjYKkVNtCDO0mCx7/Eo29wpW+V07JTYh6hWpwxISoyA5zRb+4l96xo26G/4HkYrL3B24Hi2PxY7caj7Sg5uRqlVGc9NpIDObOMpXCYOPoYKM6jQtCpk4gbaBgh7VWlziy6gYT0e6r6y1dbMYv0/mlAKhTWcKAKdhJAdAkKxawdnj+fABKgVQUrFw2PnEmQmbjLUfRWrHmSolrOUs+JYcYBhNKEitFcavR3BBEPA6hwMgzGSdkeV1coQksNst3Mb4mirD5gSq4NVQyOhtLVPIwo6ZVEoUOQRlmWlbLVYuRhxmN6MSgYkf8Or0GnBoe5jrPoEs6SW4YqX2utUus7y6HqiaLYtp1QcTUaULrFjXa1bEcK6WKUWJTTv76vaxiDOXay7AbWOy19SOudUW0uq2c1J8NTEwRk6mSLICYZuoC0SVTO756aY2yfHWrkZ+M+WeYw5EjG24wRzRZcT8W7RS0ozDu2o1NqqrEbVEvtR0tdIKdMXubGuZuU1My276Sw/MpHtRnENJeVEhabag4Yzj6MW6KwbXr3WJdjOTlSeUofO5+XVrbZ9i/Ofa2Oc7NYqygMdF4ViC3Rpe6rLIeTozy4IZBXWXkWirrm2ausOtKHu46zcDJ6YeO6IZYCIhiIxUa1brzTk0By6MjtX8tJZhjWlwYy1jR6iWXs852vaNaz2idw+JZbBcNImxw4/UzsfmDNaHCIICtxsglO6UiiEIlRiuxaFJR58cdfMNa0cda2t+7ipvYYYi4su7ExSbV/luboPHCqmqHQjZKHU8aj4WN5bpoyC0fxdHm/lwvCQdAnRjPBFH8JkYnAry482Q6WZLrtQ8sBKW6qwcsPZPRJo2gJpFhz1taw+CS8Gx0s5hKRSZefhXzezrSOdjEs4bygIHAgdT9FDePEsF8xXZfcd6j7Bap/UyvOPGQXrO7v0SV3ZEqwg6ppiwEW6YTPKZifLGI9dIo6f2ZvL1Q3m/X1tW3+3vXL9QfWhr2EtYu1wUlg11A43CLFUc0nJh+Nods8mI49IKX/WVyyrc7vqOtY+oTuS2VqoBNohBnEh/UYQrFf6bLggpfILicZDH2rjIz+C6NdueV34MNR9ok1uRZ2VPFvpTGd3pSrfQYl9jTWuA/O8ZNjjKJ7dkzk7/cqnme0gKdp+rk+ua9Xf/AHzQHde6m4mOhIPoteRYmwGIlu9shaV2PS9UoXrqFzR8eNE97Eats9JVh3bSYlgZOvqm0aEHYGKTCm/WSOIByo9IpFB1iTt2NTpIR3DzIqm0D0uc5vtelZOiYmCl4dDSVhPSYUxvqmqpOP7csaj67YmIvLawVVqTx5Ro0y6qtb596Hu61vXHRj/QHEjlsZaachi3XXAcpDxFJF4EGI64FPHtU6GKG+nbuPCSoZXXfiuJ9veJT4plunskBeLsC4LEmHc6LZ1ZFaaBl3Og/NNdAyY0hjjjcQVEWAItLmNfAOr/taiECtXnW4OV4Rb3hVEsXz5WC4IAQ14CpiHPNIq1eiOc7QVbHazsAdvaJ2XsDNKLqVjpgHhWmgdJQdkTSQuXWvLRqEji7D2UClER+CVQyW81g0O7WJNu5GVo9YxN23YaJUYBz4AvkDJtTDBE6UQ0GU0uTLANorWKXkLTyuwMJTod5F/8MZW+xvDFBeHvsVOaDttAYcIwIfSNtMu1xZwbeCAFMR7iLSBEaaU2UmkHRZtrk9uYp07YZvLxMMR04YQGRNw0goHdDCysB2ESggKsNxhXvI2tWOqh3vG+e76hU9yilV/l8r9VmH55ZGSG4VKNtziBkKLs3jS8YyNLtAl6Lo1EaWdwfjB20PNUP1Q902tfdIVmVJJMLWlndBUhXjAmCVa+hmyg5r6VtkGlHW00VFshfRyiET40KHum1nnTq48tHhzaaEEcLNUjDmGGUM41tYr4qCVLNlAsuoqhBaeTyYRZlW86O+bW+cOxk0EoZOGsW5B1FXUWCcNS4bOps1uRg3kEUOaEn2OGjk5sEOME21XmdddWXVViItKSLLSzdaxTtxESnFUxJiqcMZpKZaeyZgoBwomhPaOKelMrry1i7vZapvcOLrMhFy2T6lgX6l9jnki+pIWKYxcd5B7Ir1jZcrTxSTy20Ry8POh7sbOD+qoG1EbnSCplD+brtdN0Lg92pWI5wbhiMcFYZDO9m5g2aIR8EkZhPN32VrnJTwSodGMJV7TATatwLlMtOUYhQufiekPkUd3RNo5U+oQFuSP/qMD4EPdnZVH1n5d7XDHE5ETG0aYT5WmYDhrCYLLts209OrqJ3QL/mCi2x9zY3z3Vh5CuR8qXUVyZuJg3TVKLECBQKUUTgn2IGemu+F1v4s2HEGO844h79tF7OgWtrqVm65loaoZ6Zi9vU7RiMpV2mVdMCUSKNKeFt0pp4PiIjdlPyvX18InuaWVr1LqL1wcXeAF/cWSM9stiN9GoDVTUrJsdjg9J1iqw9KN9rv1un040raSoe5bWe3YvpjNbxyvWlfTzfwIFBNEfqULsKM+T5XCVIk6u77W7dq6k4EwU6ZDgUPdt7b2t7IM0TjsR9SxLnltaUDLIGPIwSIQEmxlzqFsdK4GC0LJoHhcot6Zv8vbWOeOGGf0Xd4hClwgSw+TWafMiW3FWITYcDKvIF/xXYiIMjZLJRpX4tFFTOBUq8+t+zcibc2ErCbEp0trdCdCobSG6EDeL8sH5g/0BLFjxY9EOmOl6Ma9ue1zW5vcDbMnKpQgUpe8id5uobpi3V9VKQlyjMWJN6xE7IH2yzOsJD0VMwsW+5RuZ+WrsLKZ2Zly1ejyCoK8UPOVUnbCpGHLEe7Fb9B99Niega4YwRaK85IFqO7n9slpVt6HYK42aeJAKvdkqgBzp+uGtJ2DmDfEUIJLEev8CxQoC2uJA5DqPmo8uvm7vL3VZsN2wlNCr/XMQSICjfIOR4nuX0dU3mek2/ryTKcJ8CiU8LXWbutWFznOx/cdbHKj5YsI1rLEF9G1IA26WUmyqkK3eej6mUqZCipdIqDUA7qeIleuY95qschRcrp17mBH9wTdIE8jXScZKjuBjucywHWimXjzbK83McJaG3x17jYqasLrRJmquT45w25r6oBSq4iddoAqYznLr/YTMf1zqQM0U6VUe5AfaPqO/2ChoHe1J38u9x2tfdLg8MFvY7Yr/JmHgbLr6vhR2So4g06BTC1wZHXlXKvDrrgMOcahLkCZ9/edbO+SsBlB/j7WPV1JH+tqIAg3tB7xUt34DUt/5q5Kxau1cbEkvI0FrjtfsZE3bav7zkbdw3bW4bl32WXx8/Xms8/JJy7n12KuWzx6Vr/5M/P5e45knVQemMF1o+cN8oz7Z/g69N1dd9le1i2W320x2mT+znzOXS3PsdW1/0R16XO9rdPJdcBEcun7gRPVNXUbD5pILn0/eKK6pm7jIRPJpe+HTlTX1G08bCK59P3wieqauo1HTCSXvp9rorqmbuO5J5JL388zUV1Tt/HIieTS9/NOVNfUbTzfRHLp+/knqmvqNl5gIrn0/YIT1TV1Gy80kVz6fuGJ6pq6jReZSC59v+hEdU3dxotNJJe+X3yiuqZu4yUmkkvfLzlRXVO38VITyaXvl56orqnbGEwkl76HE9U1dRujieTS93iiuqZuYzKRXPqeTlTX1G3MJpJL3/OJ6pq6jcVEcul7OVFdU7fxMhPJpe+Xnaiuqdt4uYnk0vfLT1TX1G28wkRy6fsVJ6pr6jYeNZFc+n6lieqauo1Xnkgufb/KRHVN3cajJ5JL34+ZqK6p23jVieTS92MnqmvqNl5tIrn0/eoT1TV1G4+bSC59v8ZEdU3dxmtOJJe+Hz9RXVO38VoTyaXvJ0xU19RtvPZEcun7dSaqa+o2njiRXPp+3YnqmrqNJ00kl75fb6K6pm7j9SeSS99Pnqiuqdt4g4nk0vcbTlTX1G280URy6fuNJ6pr6jbeZCK59P2Uieqauo03nUgufb/ZRHVN3cabTySXvlcT1TV1G+uJ5NL3ZqK6pm5jO5Fc+t5NVNfUbewnkkvfbzFRXVO38ZYTyaXvt5qorqnbeOuJ5NL320xU19RtPHUiufT9thPVNXUbbzeRXPp+2kR1Td3G208kl77fYaK6pm7j6RPJpe9nTFTX1G2840Ry6fudJqpr6jbeeSK59P0uE9U1dRvvOpFc+n63ieqauo13n0gufb/HRHVN3cZ7TiSXvt9rorqmbuO9J5JL3+8zUV1Tt3HrhG2870R1Td3G+00kl77ff6K6pm7jAyaSS98fOFFdU7fxQRPJpe8Pnqiuqdv4kInk0veHTlTX1G182ERy6fvDJ6pr6jY+YiK59P2RE9U1dRsfNZFc+v7oieqauo2PmUgufX/sRHVN3cbHTSSXvj9+orqmbuMTJpJL3584UV1Tt/FJE8ml70+eqK6p2/iUieTS96dOVNfUbXzaRHLp+9MnqmvqNj5jIrn0/ZkT1TV1G581kVz6/uyJ6pq6jc+ZSC59f+5EdU3dxudNJJe+P3+iuqZu4wsmkkvfXzhRXVO38UUTyaXvL56orqnb+JKJ5NL3l05U19RtfNlEcun7yyeqa+o2vmIiufT9lRPVNXUbXzWRXPr+6onqmrqNr5lILn1/7UR1Td3G100kl76/fqK6pm7jGyaSS9/fOFFdU7fxTRPJpe9vnqiuqdv4lonk0ve3TlTX1G1820Ry6fvbJ6pr6ja+YyK59P2dE9U1dRvfNZFc+v7uieqauo3vmUgufX/vRHVN3cb3TSSXvr9/orqmbuMHJpJL3z84UV1Tt/FDE8ml7x+eqK6p2/iRieTS949OVNfUbfzYRHLp+8cnqmvqNn5iIrn0/ZMT1TV1Gz81kVz6/umJ6pq6jZ+ZSC59/+xEdU3dxs9NJJe+f36iuqZu4xcmkkvfvzhRXVO38UsTyaXvX56orqnb+JWJ5NL3r05U19Rt/NpEcun71yeqa+o2fmMiufT9mxPVNXUbvzWRXPr+7YnqmrqN35lILn3/7kR1Td3G700kl75/f6K6pm7jDyaSS99/OFFdU7fxRxPJpe8/nqiuqdv4k4nk0vefTlTX1G382URy6fvPJ6pr6jb+YiK59P2XE9U1dRt/NZFc+v7rieqauo2/mUguff/tRHVN3cbfTSSXvv9+orqmbuMfJpJL3/84UV1Tt/FPE8ml73+eqK6p2/iXieTS979OVNfUbfzbRHLp+98nqmvqNv5jIrn0/Z8T1TV1G/81kVz6/u+J6pq6jWf+zzR1rZuorqnbuMuEbVy/pG3cMGEbNy5pG3edsI27LWkbd5+wjXssaRv3nLCNey1pG/eesI2blrSN+0zYxs1L2sYtE7Zx3yVt434TtnH/JW3jARO28cAlbeNBE7bx4CVt4yETtvHQJW3jYRO28fAlbeMRE7bxXEvaxnNP2MbzLGkbj5ywjedd0jaeb8I2nn9J23iBCdt4wSVt44UmbOOFl7SNF5mwjRdd0jZebMI2XnxJ23iJCdt4ySVt46UmbOOll7SNwYRtDJe0jdGEbYyXtI3JhG1Ml7SN2YRtzJe0jcWEbSyXtI2XmbCNl13SNl5uwjZefknbeIUJ23jFJW3jURO28UpL2sYrT9jGqyxpG4+esI3HLGkbrzphG49d0jZebcI2Xn1J23jchG28xpK28ZoTtvH4JW3jtSZs4wlL2sZrT9jG6yxpG0+csI3XXdI2njRhG6+3pG28/oRtPHlJ23iDCdt4wyVt440mbOONl7SNN5mwjacsaRtvOmEbb7akbbz5hG2slrSN9YRtbJa0je2EbeyWtI39hG28xZK28ZYTtvFWS9rGW0/YxtssaRtPnbCNt13SNt5uwjaetqRtvP2EbbzDkrbx9AnbeMaStvGOE7bxTkvaxjtP2Ma7LGkb7zphG++2pG28+4RtvMeStvGeE7bxXkvaxntP2Mb7LGkbt07YxvsuaRvvN2Eb77+kbXzAhG184JK28UETtvHBS9rGh0zYxocuaRsfNmEbH76kbXzEhG185JK28VETtvHRS9rGx0zYxscuaRsfN2EbH7+kbXzChG184pK28UkTtvHJS9rGp0zYxqcuaRufNmEbn76kbXzGhG185pK28VkTtvHZS9rG50zYxucuaRufN2Ebn7+kbXzBhG184ZK28UUTtvHFS9rGl0zYxpcuaRtfNmEbX76kbXzFhG185ZK28VUTtvHVS9rG10zYxtcuaRtfN2EbX7+kbXzDhG1845K28U0TtvHNS9rGt0zYxrcuaRvfNmEb376kbXzHhG1855K28V0TtvHdS9rG90zYxvcuaRvfN2Eb37+kbfzAhG384JK28UMTtvHDS9rGj0zYxo8uaRs/NmEbP76kbfzEhG385JK28VMTtvHTS9rGz0zYxs8uaRs/N2EbP7+kbfzChG384pK28UsTtvHLS9rGr0zYxq8uaRu/NmEbv76kbfzGhG385pK28VsTtvHbS9rG70zYxu8uaRu/N2Ebv7+kbfzBhG384ZK28UcTtvHHS9rGn0zYxp8uaRt/NmEbf76kbfzFhG385ZK28VcTtvHXS9rG30zYxt8uaRt/N2Ebf7+kbfzDhG3845K28U8TtvHPS9rGv0zYxr8uaRv/NmEb/76kbfzHhG3855K28V8TtvHfS9rGlV2mq2vdRHVN3cZdJmzj+iVt44YJ27hxSdu464Rt3G1J27j7hG3cY0nbuOeEbdxrSdu494Rt3LSkbdxnwjZuXtI2bpmwjfsuaRv3m7CN+y9pGw+YsI0HLmkbD5qwjQcvaRsPmbCNhy5pGw+bsI2HL2kbj5iwjeda0jaee8I2nmdJ23jkhG0875K28XwTtvH8S9rGC0zYxgsuaRsvNGEbL7ykbbzIhG286JK28WITtvHiS9rGS0zYxksuaRsvNWEbL72kbQwmbGO4pG2MJmxjvKRtTCZsY7qkbcwmbGO+pG0sJmxjuaRtvMyEbbzskrbxchO28fJL2sYrTNjGKy5pG4+asI1XWtI2XnnCNl5lSdt49IRtPGZJ23jVCdt47JK28WoTtvHqS9rG4yZs4zWWtI3XnLCNxy9pG681YRtPWNI2XnvCNl5nSdt44oRtvO6StvGkCdt4vSVt4/UnbOPJS9rGG0zYxhsuaRtvNGEbb7ykbbzJhG08ZUnbeNMJ23izJW3jzSdsY7WkbawnbGOzpG1sJ2xjt6Rt7Cds4y2WtI23nLCNt1rSNt56wjbeZknbeOqEbbztkrbxdhO28bQlbePtJ2zjHZa0jadP2MYzlrSNd5ywjXdagzbuse13Wxa/Wjlq23/DOA6DoM3Dvu3jNC+jOsziLOuTPs+KpO3TpGrzLkyqOCq7POjDouvyNG7yrC/bJuuHuvdfWci93qg/OGefaNO2OjcZsp+89cz/7kr56aaz9tcB2zAbjf7aZMi2j/F7E//jLYs6f7HtDzaP/kbf9105a59uXot2R1my2jsLzsknjKOhP9Zv3b5f9tj23w1b16Rd+e7U8cRtnbhp9A5m78V4rsqBxu/WW/C7rJwVf5AFf6CBGd7XlhHe7Os9VrZ/7xP2QWrr/wOMZ+uzYeuaPNva/0Of6DPu/y2W/jTx4/63va8tBmbo0y0W/A22nvV3+xp/NzzTNif32/Z9tTkTtX1Rl0nQpUUZdEkXxnneBWmcx33VZWUVtnma9FkZp11W5UVQZ1lWJnkSh33UtE27h0Wmyd5LXGb/tTkZl9V/e04Ofbozc3LFaH/UNW1RtGFaZnndpHFdFGkZRl3QhlmRZSFrWFNnVdVEbdwXaRflTZV3XV9HTVgGRTweNxP3b/5fm++Od7uv0Yc78m5N/M6+26FPbe/WHN9rpm/jsrD1v7mO67Nh65o829r/pn4a9/8Blv408Tuibw+w9LFN3w724fC7/Yy/G565aWX7ebdu23/XVCcGQbJu9LyhjebPzOfvubKG4wjLad3K9vNhtXe0h6VfJxxb5WpjZvMq8hy4FvJEWbaaTtjHIo/6cdeV7ceQ2V/mWDblPsiof/iZy14xn32jrWf+d/Oon3Z2zK/JWrETY354/n9qzJ9dv+4y6rt9LbKO7Tp9BptvtbllW3/+U3VN6IdF4x/Y1uPxOFsT3REE6Y6Os+H5e66sqa6fj7P9RvK43tnYTjX/dsvK9npxPDZsOtNmw/pSl01/mWN2neO/w3PGPxs/x+bDraYn/6fPsXEtq82T/+lzzLoGPml4zn4TPsesa8zHme/1qG3/Dc7ZJ1zTNT4Is6GPzDV++Ay/O9h49nhMHmL8bjyODjV+N373hxm/22/0u8ON35nzYfxZP/q32U+y079n2Olj3PDZw/KcCfs33TSSy/yM+97Wv2bfj/vX7Ptx/5p9P+5fs+9Ne2n8sfXv0E872r82u8xcA806N1jk0meYZ2OOt9/WIWs7R4LAlHdl9Kw15Y2DMLHxN8Nnk6Xd4/Fj889tY2s8fsyxNW6/+bGNkaEvNEaO2G9R7xg3fFaz3Yff2Xzg4XercU9bLHLZ1qYDRr8z7aIDR78z14Abbl3gxuPWtt6P/ZV9LPKN/71xhNVnbGcM7dzROTTg77mtUr2rk7Y1bG9D5urOtz3h9s1pbXfdO552enWL7sSuatc55ByPjzFuHwfOxiuP61xvqWM1Ltv2vI0jzP2Mtp9sjNNxX59Tm8GUY7eVsz5ntwmfs5uB2X3b982jf68b1W/+bnjO+Gfj56yzPOfs4nqP3Mf+TFdcbxfj9yb+E0Zc7zH7nPXZ6xzPftzo2btYnm3+7U22nvXZA/6hxrOfuK3OzSOMTT9tNH632+h3u1ravG70uxVDTvNn4/di/v2ujr8by7PBwOxm+fthPVu/SlvG9bieZfb18PPhHehzs63255vP2mCpW5+xfhvwzx/ZCLuP5Dlq27+Dc/ix2QjjOWj2xfhdm21Zb/nZau96o6Mu872Z4+b4rWf+dy11kD7X3HrW57jm5yt2QDeY8phjx8RXxvx89ei972X8/XTvPQkG2fY2+sg2D8znm7puFwO/9yr4PUfyj+vfNMIPf2/Oy6EOfYb+3zjCf2qfRR++aR+7DIPM+gxjyXwve1jaM+VcW62N5jPH42TAv2vUrkFfr7f0lW1+bbI817QXhj7ZOMK/y7A3brTff6Kvdt5/GPNxpv+w6+h3pv9g9tf4Y/MRhvaqL07ZAR9heKb5Lg4c/c6cM4PctvV5/D53Gck6/tlYx9n0+FjHmbjhd+baM8iqPv32yI4xnz3Ut8eKfT09atu/g3P0CcMd0ffm8/dc2b5f14I/tq2Ltncz9M+ea9M/wVgHmvLYdIVtTI7H3TAHzHXOxJv6dqwj9jbk2Dj62Te2jactozr1GfT+Osvv1lt+NvSvxumXHPa2bR7sbnmmOdZtNtG60fedtYls43Rcl6njTRmvtfWs+KHvNzqefe2ti9+b+B8ZOv4b+521Tltfr7O0Zzw+TLxtPG1e2X4cDn+7xmtxMl4Tbf07fr65Xpr2z6ZV8GP7bVz/Po6+G/D6mO/YZY/tumKfB8Pfjtf03xrv+9v7LfpgLNO4PavtZR1+b7NpxnbeWP5BV+hz463bP9/GV6octe3fwTn8jN/vBuMZmy39Mea2/jGyzQYebr2lrbZ+3WJ5rhkbGvpkzIP9w2Kbjduy14pd528a9e2eK2vSt8m4Hzeu2Mf7niN59l4TeaJgzKdt2PZFc2iXbd9tNo25Huy5+ayyDXXtuWKfR+Pxv4+lL2zjYzzOdt/2oFkcYz+7rKY8NlnH81Wfk7YufjbWMWZdNh0z/O24X/cxZB3rGBffuW7FvmaM4xS2Ph7LPdbBGx19sOfo9wP+IGNcHDAaFy6+8IKjvh7qcum38d7DLaM2HLXt38E5/IzfpalnbDH18bs896hdA2+03tJW2zvd1/JcMx4x1m/7jp5r8z3XZq9REezonB6PN9ucNjGuOX3+Vea0qRPMeXhBh/5ZWdne37Dpny1GXTb8WFcP+Isasv5w5P+a+1qHsb6m+1rx/2z7Wk2dvXEk06ZV+mllZXtb1harMftysGVXi9uZumhl5ay2uWnLn7B18XsTf2VDD8Xbvm8eYdZZZF+3sr3s6yxt3eL4e9dzxrEg078w37uJnfa9B+W60fOGNq44ZN1zJOvE8sz9/t1G8pzd+LLFsNatgreNX5tvqSmxeSSTOTaH55q+yKbRz1bjAmzxRnMdPG6VcbrbqE02f9nslyH2PO7jXVfsPtWYPx3wxzp0l02X29po1n12bbTZIuM2rjYXbfL8p+a8Le6xzvHf4TkrZ/Mcm8yr6Y//6XPM+T22rdYohrYql2COnXEse7PRBtvaMsaPdem4/vF6M/y9LVaqzziWMuAfaaw3p4zsjNXaqM+Yjxrb7WPMWBfY7JLdLPWP7ZLa4muM+80Ws9dnzIkN+M6oc8yJ2eyC1fT8amc1THnGOtv82/E+ZNs7t9U93ittq2fsd4zb6fJfxueQDxjVc9S2fwfn8DPUN/gMph9xgKWtG0f4M0bj2Dy3sW5l9T5TOdDyXHPv6dh/OXD0XBs/M8hm8jPmex+/k91GbRvLOfZjB/zdjPl8l5Ef6+K777PZ/mzTF9pvFVn3tMhqYsa+0IC/1yq+kKkPTRvgPkab9DH9EDPOos8G43dr7YeYemvjVnv/rKzY9dyOcOo2Lm/LCG/2m20tHutfW0xxtTXGZouZ+PF+qAH/cIsttlqccrYXa2RvmbLvSNzEto7YuDPTxnvsZnu95lpi9tl1tp61vQP+RGOPxxO21bm2sdGgGL8j084wnznEx9c2FrnQ4Ta7ZE+LPGO75Jk7YIu49oKZc8J8rs2XH8cln2nR4ba9LOb4stmcKxP25Wp7oNb4Pe6w7z08f8+V7d/NWvjeO6pT1zi2WGgZGHSZuX/tulu37xuXrj67+MNLRnPBnDM2Pm9/4/cmfk9DL718pF/H88eUy3z36xz/XVlZ3WfbkTG8Nj5btMP7Robn/6fGsI0PWm0Mr80cj3Z438h4vNrG8lhfm2PUFv/bZWV73Wz6a+NY9ju2jdux7aPP9beeVQabHWX+zLQ33rSKrfw/HfNbVrbvm/HeanOMjXkgG7+42yrP2cvynP9bO+afVdcO25711cbRXqvgbbyt7b2ZvO0gk81vWo23Xc3OP7t15ZM7ua6MbaYB/y3D5/zMKjzpeK/5eF+eKcvO7nc0/35H9q3b5useK9uvhWuhZ23zer1FntXWiQ2r4G3jew8Lft+V7X2XcfsHWY80fra75WfDM48yfjb2B4d/f3PkE5ljZEofxHbeYfiu+WvTwWOsbT/czvrue1n6ZLX9cDb/xnyntvMCKxP22ybLM8drxhrZ0zucI2J4/p4ra7qGhau9V7N/xjpk09rIk5j+hjkOTX/DtRfPZV8MXIE+Jl8/tt3NNdJcR37l2AdjriPm3455/QH/B2Md+a1jbVpZsa8HQ9zQxvEMf2uueZtXtu+TsQ1re+ercQ62/ZkmfsyDDvi/Wvixoc59LDLYxt2At+0N2cci8+aV7cfHmO8z97jY7OfxGcQB/29LLMXG1w59v7Z8bWTla81+3bj1rO1erQ/12ZF9I7Z9pLZ9I2Mud7X9wra1yJwX4zlgO9tlm6+7Gu2yza1hvu7IOd2x7aHPwJOO5+V4Tth4NhdPt2VbJ9ridTtqf682x8x5MZ4zpn4dvyPbs23vaPzsXVfs7Tf9aBN/sNF+l87YuLJj3OeAP2yVPrXNidX69OzmxDgGajszvyN9qu/7r9hl3dE+HfDnXaVPzT1yO9KnA/4Cq/SprY9W69OdjSub/T2OcZ7dODX3CJvP2dE+HfAXX6VPbf7man064C/1X+xTs83jWL1rz7/pc5p26/jv9Bliy7Y693HUadNfq53HsL1Lm04bv8tilXdpa9c+O9iuzRO1a/NOtmvAX2GN2rWro1277mS79jmbdo1jaAP+6B1olzn3zLV7vE9mwB9rmXs2226wEf4bsfiznDvcetZ22/SejRNebQya78fk7cZzdNfR79YZvxufd5nKv3nJyL8Zx8rN77a9UuYzXXulrr+DY8A8a6/PBuN3/839GDsadxnwNj7NtIHHXKQth8GO7Mc4u3PEq40B2z6GzavIulpfrJZXx/z73R11mXyCmXthaPva5rsItotnmXsAbHttx/uSTt1yVszZnRsdz6vV9h6YfTLWraca8+p/W+6F8d4I87N+9G+zvTube8HkAXcm94Ip3/hs5M7OEVvM1PaccSxwtXjqjsYybTzCgLOtj+M5uUa85Q7HAofn77myluN+weva7IHV+DWbPbD7Knib32x7b2Ys0OSEVkbPNd/r5tHPbDnWxnbG2Z1BGa8x5rsZ/taWD8kWr7PtKRmvdS5/chw7GvCPXMWmtbVttbia7d3b9LrNlhqfp16bvSs7r5/H+TNN/TyOC5v6eazXzdyaZrvHH5vuNs8b/WQHdPd4TAz1jsfVwDeP37frXOOYP5jvLdzJMbRarHVnx5D59//bxtD4vJg5hsx2jz9TjiGbHhrrQPO7TQ/tbZF7rIdeuZNjaLU15f/00OJ3/z/poXfu5Bja2T1H/6eHlksPmbjV7CxzX+I4L6zNnrTpgwFv43pNvOvs/2csY3PzCGPTpzb+3fzZ2E8x/37LSJah779oyPIXxzyxxRD0ucpWe51f2ckYwjpLG4af72wMwZxf4zN15t/5OPc2j35nzr2d5QCGvtjZuWfTnebfjefeJouMZj7o4b3Zzh4Oz7TdP2XO1fGYOdiCN/t4PGbMd3Pw6O/M/jdxGx11m89esdQxruegEfYQo03jv93iqHdo/4lbt69n+Peho3+7ZDb/vdEi76Gj3w3YP24Tbphr5h0TU/KPtn2H5rNMec09F+Y4HGLaNl79v3lvq/keNm49a5vM97fegh/PgcMsePNOkPGdBmYfHjSqy3aHkXmfiTnnZ5iti78fZPxv9Kcp47g/V7vnUp9xf9r63+yn8f0RZl8fMvqd7W4Jmx4c35Oy2rjWZ7yvwKYH77yLu42HWPAHryLrQZY2rvZs25hZrX9Xk/XsxvfBI1lN+cb64tBVZDX1xYA/fCdlPcKCN+84OnQkqynf8Lf/NV3luPPU7LPx3LL1j4nf2f4Z66ojjN8dtEr/HPpf7J//5H3LB4/6Z7V5aXu2OVdX0+X/zfFm9sG4P1ez9/T5n+q5LStu3TG+C2hH180dtZWHv5Wt/NNtvxj0g+tuVVNX2Z65bmV7/9I2Hlazrc9uLI5ta3M9O8jxbNOWNnXteE/RgE+3dcDZ7ZH4j9wJHcbxWtseZ+fPDH22ZWX7sTy2S8zxcuDoOTZfe0fH6/C3Gq9HbiP1d2S82ubIavvBz+5+7PH429/S3mUbK//JtcKMf57dOHLd2zzlWDlsNFb2s+B2VLeN94svs24b83ED/uQd1G1DP63teA290m02v2rdqL/M5+zoeB3+VuP179vINBtfOx6vNt1myvGf0m2DjP+NsbKsus18V2PdtlquWn1WGytmTOCPo7Fiyzdn03vrRt9tY9c2jmy8/4AbxyDuYuiZvzg4+h3l/Qf83S26a7U2rLO0YTVdb/bReC6Y83D/Vf5uzKGeXXvNdWXc3vsukx0a9Nb5Z7Z3PP9sfWyLJ62mz0wdNJ5/q93lbp5LGPskU82/j22bf2vZ73lx5p7Ymazb6h/G0fizwfi9iX/stnc2vkNL/91wDuTs8yrs46qv0qptk6ay3eM7vOO91uD5dRd2cd/3cVclfdaf7fPnZ0y2Ln5vziN9dtv272H/7xhv7ikx8U/d1scaF0835sgMa3mecC9bBbfO8d9ZHZafbdh61p/tsXV7/Pqt2+Pneza3bi/j8Lu9jN+Zc1yfvbf92+wvs65Bjo0j/Iu3tX2+D9L4m+Hvt1iev/vo+WeR2/Kz8Z6BvSz4vSx4vZ/njOaN2fYJY07zHFe7juo3fzaWbRg7GtfSy48Y6WVz39t8TGz7vjZ5DKP/8R1vG9ZEntXveLPtC/xP5ZCxnReynZsen4cZvzsV2x4KW56DXUZ48/vw9+bP3rZtPNnyVYzvBt/RXFeS5Q2jcWq+m53VeWO71Oyb4f1uXtl+jK0bfd9gkX/DKs9ZZ3nO+N/jvDn6nLL1zP8ObTfXcDMnx/v3Pat8trO25t+OczkM+I8Ya9KHDH07bsPQb668OuMxZ+Yj2hFbe7WcRmZbVjvPYfs72/gd+v+LRts/bZBJ4zkzfkc33XrW3w3Yz2+rY61zr9r2HwzPGsaNqSuG/tDPvrzvzuP0MW2g4b3/N/J6nOV9Gs91jbnVzm7s6JiznfsZn32w6Wtz/g3+gk0PjfMurrc8x5zz5lpuO7c+nivjO9JNuYdnmz839fL4TvMB/9PRWB/321Hb/h2cw49trO8xaoN5L/t4rdTnpFEbBvz6bZUL+4tV+nN4tq0/dxn9bry31vydKff4Pdju+tx9lTYM+N/voP9v5oXWZ8PWs8p51LafB+fsk9jmrDnPxnPWlvNmtb30Z5d/bXxWynYX97rRv826zD4f7w8x5+IYb9Y3XmP/ZbyjcX50mw63ncXdbfS79ZbnDr8zx5ap0w8fnTldGxs2yMc2qfkZ63GzDzatbD9PxucFxmuq+TtzHJh9MP6MeRGzLyTXETuwF3VKPbFh5azPW5Z5a66n43m7ozkod3Sej8/R2+6pss2ZPUa/25E5o894PTbHi7lHeJgzLh96o6UN+rvz7EAuHPNvx/p9wGfGGnW+0T59W+4H27gcj71x/l3zd7ZxaVu/xuPeZnvZxsMWy98PONu4G9q1xjb1DuelHOcyXiO75/81d/U6TgNBeHNHQZQLQjyJ13HsWLwFJQ1KbKeiokBCFHBC11Ogk5CQKNFJNPQUSIgCiYaOjjfgGThLLHz35dtxzJ2tS3O6ZLK7s7PzszPxN72xjAfGXMgs/xvDnr3ldmWmemji/Thg0SldZzuAus52AGXHdkDpOt5rVSw9obGUHiu9UPcC1Ptghzg2vQt6f4/0XuHZWlggSn9Z71FGHJsqmVv3KvWsmorDFEbnfI+xLoP1x3Mr/Chei3Pxs6t89jjYSMlS+Wz0s+yz++Kcd+FzsT6qHtkWLo7S4xl9hvrHOo7nNJxf1Bf20aiP6KOvuuaUpHWVN+l5Wa7IfVrWY9e8iqxKC18kTZHmzWK5GXv+PMv9arVeVXm1LbOqc/6uuIpjgGHuLX7v2sTffitu93wNEQN0+RCOAYbpr+BNfHtVT1B3vVjcqPIeOO6B2/VhF+4n9N5Dumejvwpx+kR8Zvm3du1bsi0om0nkbxiX37Ni4liuQmG5oZ1kHIMXEEc8ivTSdE7nLBnbSz0Hr+IszhU+/jOv9Rx8jK/YmE+BrycRe488tHTHEf4nzt7Tffk/iKz1GfD/0/BN2H/vmOjQ1yGmxUmErn3hffSEeA9rPXS6nsU99YaqwbHtGgab4N/9ZWrwzfNjXIHPu00NenWmVJzCZ6pvX99TOP8v99BrrF9xXrML3yKmg6+EXisZ47k+Ne4yXNM+EPvQjvGa+O2yjbz+QP8W9vANrUv5+7kYO8h25nSN6rK6YvmtKXxHyZn7N89gXnV3Z/oufEW2d4H+HZyL+4ZtRpme3dFzx/Jl3GMi0H8Emb438mWM+W7ptOWj2hfjqAb6D7AP1xVH1aqnWriozvXL8eKeqRwv1/S6MHo4f4uxE9dTcZ3oO9mOqPVPxXcD/RGMpeixTwrSfzLiIYXbrOoaPOYXOPefSedQjqGHXkv3PTI38n8o+An0c8E/0sf6oXw1+Fe9ZXBdD55fHDPQfxO6xutEvpTNDe935ZDCelT+inFVVO4T975PnxrEKMezyhjlOBbnyy3dPhJrtWSt+j2yrH8YMcLNyDpj61N5UxVHYy7obKAcT7XMN1W2XCeNb/9Nx86xpKtVXqabJCvqaltni7Hnr8p8Wy4WG78o66b0+djzn299Ua0L78vMN5lf9skx/W/9LNCpGgDem9lGBfpf1yke8Fmj4oGrxFW3fo+Fe3bb7frOG/QZnhsrfxzkNsSZazZZWWzKapnUSenLTp37DUcnCug9VgUA","debug_symbols":"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ZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nTjadOtl06mTTqZNNp76AO2wnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6ZRk0ynJplOSTackm065gDtskk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNNpkE2nQTadBtl0GmTTaSzgDjvIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbTgNsOukCNp3W8NwOu4bndtg1PLfDruG5HXYNz+2wa3huh13DczvsGp7bYdfw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw5A4LNp3W8OQOCzad1vDkDgs2ndbw4A4rZNNJyKaTkE0nIZtOsoA7rJBNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScmmk5JNJyWbTko2nXQBd1glm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppORTScjm05GNp2MbDrZAu6wRjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm06m5A5LNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTk00nJ5tOTjadnGw6+QLusE42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNpyCbTkE2nYJsOgXZdIoF3GGDbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm05BNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm05BNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm05BNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm06NbDo1sunUyKZTI5tObQF32EY2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZFNp0Y2nRrZdGpk06mRTadGNp0a2XRqZNOpkU2nRjadGtl0amTTqZNNp042nTrZdOpk06kv4A7byaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDp1sunUyaZTJ5tOnWw6dbLp1MmmUyebTp1sOnWy6dTJplMnm06dbDol2XRKsumUZNMpyaZTLuAOm2TTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0GmTTaZBNp0E2nQbZdBoLuMMOsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMAm062gE2nNTy3w67huR12Dc/tsGt4boddw3M77Bqe22HX8NwOu4bndtg1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JNpzU8ucOCTac1PLnDgk2nNTy5w4JN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","names":["add_zsigk_len64_signed_ecdsa256sha256"],"brillig_names":["add_zsigk_len64_signed_ecdsa256sha256"]},{"name":"initialize","hash":"17125905314152633262","is_unconstrained":true,"custom_attributes":["public","initializer"],"abi":{"parameters":[],"return_type":null,"error_types":{"206160798890201757":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"2233873454491509486":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17618083556256589634":{"error_kind":"string","string":"Initialization hash does not match"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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TSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOSTSclm05KNp2UbDrpBp6wSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk2nQTadBtl0GmTTaZBNp7GBJ+wgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6TTIptMgm06DbDoNsuk0yKbTIJtOg2w6DbLpNMim0yCbToNsOg2y6WRk08nIppORTScjm062gSeskU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyaaTk00nJ5tOTjadfANPWCebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmU5BNpyCbTkE2nYJsOsUGnrBBNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm05BNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm05BNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTacgm05BNp2CbDoF2XQKsukUZNMpyKZTkE2nIJtOQTadgmw6Bdl0CrLpFGTTKcimU5BNpyCbTkE2nYJsOgXZdAqy6RRk0ynIplOQTackm05JNp2SbDol2XTKDTxhk2w6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtOSTadkmw6Jdl0SrLplGTTKcmmU5JNpySbTkk2nZJsOiXZdEqy6ZRk0ynJplOSTackm05JNp2SbDol2XRKsumUZNMpyaZTkk2nJJtORTadimw6Fdl0KrLpVBt4whbZdCqy6VRk06nIplORTacim05FNp2KbDoV2XQqsulUZNOpyKZTkU2nIptORTadimw6Fdl0KrLpVGTTqcimU5FNpyKbTkU2nYpsOhXZdCqy6VRk06nIplORTacim05FNp2KbDoV2XQqsulUZNOpyKZTkU2nIptORTadimw6Fdl0KrLpVGTTqcimU5FNpyKbTkU2nYpsOhXZdCqy6VRk06nIplORTacim05FNp2KbDoV2XQqsulUZNOpyKZTkU2nIptORTadimw6Fdl0KrLpVGTTqcimU5FNpyKbTkU2nYpsOhXZdCqy6VRk06nIplORTacim05FNp2KbDoV2XQqsulUZNOpyKZTkU2nIptORTadimw6Fdl0KrLpVGTTqcimU5FNpyKbTkU2nZpsOjXZdGqy6dRk06k38IRtsunUZNOpyaZTk02nJptOTTadmmw6Ndl0arLp1GTTqcmmU5NNpyabTk02nZpsOjXZdGqy6dRk06nJplOTTacmm05NNp2abDo12XRqsunUZNOpyaZTk02nJptOTTadmmw6Ndl0arLp1GTTqcmmU5NNpyabTk02nZpsOjXZdGqy6dRk06nJplOTTacmm05NNp2abDo12XRqsunUZNOpyaZTk02nJptOTTadmmw6Ndl0arLp1GTTqcmmU5NNpyabTk02nZpsOjXZdGqy6dRk06nJplOTTacmm05NNp2abDo12XRqsunUZNOpyaZTk02nJptOTTadmmw6Ndl0arLp1GTTqcmmU5NNpyabTk02nZpsOjXZdGqy6dRk06nJplOTTacmm05NNp0abDrpBjad9vDcCbuH507YPTx3wu7huRN2D8+dsHt47oTdw3Mn7B6eO2H38OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OQJCzad9vDkCQs2nfbw5AkLNp328OAJK2TTScimk5BNJyGbTrKBJ6yQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nIppOQTSchm05CNp2EbDoJ2XQSsukkZNNJyKaTkE0nIZtOQjadhGw6Cdl0ErLpJGTTScimk5BNJyGbTkI2nYRsOgnZdBKy6SRk00nJppOSTSclm05KNp10A09YJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyaaTkk0nJZtOSjadlGw6Kdl0UrLppGTTScmmk5JNJyWbTko2nZRsOinZdFKy6aRk00nJppOSTSclm05KNp2UbDop2XRSsumkZNNJyabTIJtOg2w6DbLpNMim09jAE3aQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdBpk02mQTadBNp0G2XQaZNNpkE2nQTadBtl0GmTTaZBNp0E2nQbZdDKy6WRk08nIppORTSfbwBPWyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysulkZNPJyKaTkU0nI5tORjadjGw6Gdl0MrLpZGTTycimk5FNJyObTkY2nYxsOhnZdDKy6WRk08nIppORTScjm05GNp2MbDoZ2XQysunkZNPJyaaTk00nJ5tOvoEnrJNNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunkZNPJyaaTk00nJ5tOTjadnGw6Odl0crLp5GTTycmmk5NNJyebTk42nZxsOjnZdHKy6eRk08nJppOTTScnm05ONp2cbDo52XRysunk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","names":["initialize"],"brillig_names":["initialize"]}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"Main::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Main::initialize_parameters","fields":[]}}]},{"kind":"struct","path":"Main::add_zsigk_len64_signed_ecdsa256sha256_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"Main::add_zsigk_len64_signed_ecdsa256sha256_parameters","fields":[{"name":"ksigk","type":{"kind":"struct","path":"Main::Bytes64DnsKey","fields":[{"name":"domain","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":241,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}}]}},{"name":"domain_rrset_position","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"ksigk_rrset_position","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"rrset_dnskey","type":{"kind":"struct","path":"Main::DnskeyRecordSetBytes","fields":[{"name":"bytes","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":333,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"rrsig_dnskey","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"zsigk_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"zsigk_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"zsigk_rrset_position","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"Main"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"keysigkey_64bytes","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"zonesigkey_64bytes","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"dkimkey_rsa2048","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        unsafe {\n            let sorted = quicksort::quicksort(self, ordering);\n\n            if !is_unconstrained() {\n                for i in 0..N - 1 {\n                    assert(\n                        ordering(sorted[i], sorted[i + 1]),\n                        \"Array has not been sorted correctly according to `ordering`.\",\n                    );\n                }\n                check_shuffle::check_shuffle(self, sorted);\n            }\n            sorted\n        }\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"50":{"source":"// due to the bug with the RSA we don't need a function for a TLD yet; hence can think that DS is always a thing\n// use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\nuse dep::aztec::macros::aztec;\n#[aztec]\npub contract Main {\n    // fn double(x: Field) -> pub Field { x * 2 }\n    // fn triple(x: Field) -> pub Field { x * 3 }\n    // fn quadruple(x: Field) -> pub Field { double(double(x)) }\n\n    use std::meta::derive;\n    use std::hash::pedersen_hash;\n    use dep::aztec::macros::{\n        storage::storage, functions::{initializer, public, } // internal, private, utility, view\n    };\n    use dep::aztec::protocol_types::traits::{Packable, Deserialize, Serialize}; // , Hash, FromField, ToField, \n    use dep::aztec::prelude::{Map, PublicMutable}; // PublicContext, PublicImmutable, \n\n    // TODO add `pub` and correct algorithm suffixes\n    // type P256Key = [u8; 64];\n    // // #[derive(Hash)]\n    \n    /// FQDN specified max. len. minus the _domaindkim_ specified part minus minimum selector can take\n    global FqdnMaxLen: u32 = 253 - 10 - 2;\n    type Fqdn = BoundedVec<u8, FqdnMaxLen>; \n    \n    #[derive(Deserialize, Serialize)]\n    pub struct Bytes64DnsKey {\n        domain: Fqdn, \n        key_x: [u8; 32],\n        key_y: [u8; 32]\n        // validity_to_from: (Field, Field),\n        // tag: Field\n    }\n    // TODO quite some space for optimization here\n    /*      it's really awful now, but with packed string this would be orders better\n            also moving the keys itself to a distributed storage so that only digest and revocation live here \n    while the key only enter as an argument */\n    global LenPacked64DnsKey: u32 = 64 + 1 + FqdnMaxLen;\n    impl Packable<LenPacked64DnsKey> for Bytes64DnsKey {\n        fn pack(self) -> [Field; LenPacked64DnsKey] {\n            let l = self.domain.len();\n            let mut r = [0; LenPacked64DnsKey - 64];\n            for i in 0..l {\n                r[i] = self.domain.get(i) as Field;\n            }\n            r[FqdnMaxLen] = l as Field;\n            \n            r.concat(self.key_x.map(|b| b as Field)).concat(self.key_y.map(|b| b as Field))\n        }\n        fn unpack(packed: [Field; LenPacked64DnsKey]) -> Self {\n            let mut d: [u8; FqdnMaxLen] = [0; FqdnMaxLen];\n            let mut (key_x, key_y): ([u8; 32], [u8; 32]) = ([0; 32], [0; 32]);\n            for i in 0..FqdnMaxLen {d[i] = packed[i] as u8;}\n            for i in 0..32 {\n                key_x[i] = packed[i + FqdnMaxLen + 1] as u8;\n                key_y[i] = packed[i + FqdnMaxLen + 1 + 32] as u8;\n            }\n            Bytes64DnsKey{\n                domain: BoundedVec::from_parts_unchecked(\n                    // &packed[0..FqdnMaxLen].map(|e| e as u8).as_array(), \n                    d, packed[FqdnMaxLen] as u32\n                ),//.map(|e| e as u8), \n                // key: &packed[(FqdnMaxLen + 1)..].map(|e| e as u8).as_array()\n                key_x, key_y\n            }\n        }\n    }\n\n    // // #[derive(Hash)]\n    // struct DkimKeySelectorId<NUM_LABELS: Field> {\n    //     selector: str, \n    //     domain: Domain<NUM_LABELS>,\n    //     // (Field, Field) // Validity time window\n    // };\n    // // #[derive(Hash)]\n    // struct DkimKeyDefaultId<NUM_LABELS: Field> {\n    //     domain: Domain<NUM_LABELS>,\n    //     validity_to_from: (Field, Field),\n    // }\n    // // #[derive(Hash)]\n    // struct DsId<NUM_LABELS: Field> {\n    //     child: str,\n    //     parent: Domain<NUM_LABELS - 1>,\n    // }\n    // type DomainDigest = Field;\n\n    #[dep::aztec::macros::storage::storage]\n    struct Storage<Context> {\n        // TODO I'm thinking about establish a bit complex tree structure and just provide getters for the API\n        // starting from `[\"com\"]` TODO _from `[]`_\n        // as DNSSEC uses different algorithms a `Map` sig-key value is a `Vec<u8>` to represent all of them\n        keysigkey_64bytes: Map<\n            // I thought to key the `Map` with (Fqdn, Ksigk), but there's [no `#[derive(Hash)]` anymore](https://discord.com/channels/1113924620781883405/1359702206873604260/1368975601767288902)\n            // Bytes64DnsKey,\n            Field,\n            PublicMutable<\n                bool, // is *not* revoked\n                Context\n            >,\n            Context\n        >,\n        zonesigkey_64bytes: Map<\n            // Bytes64DnsKey,\n            Field,\n            PublicMutable<\n                bool, // is *not* revoked\n                Context\n            >,\n            Context\n        >,\n        dkimkey_rsa2048: Map<\n            // DkimKey,\n            Field, \n            PublicMutable<\n                // (\n                    bool, // is *not* revoked\n                    // Field, // no later\n                    // Field, // not before\n                // )\n                Context\n            >,\n            Context\n        >\n    }\n\n    #[public] #[initializer]\n    fn initialize() {\n        let the = Bytes64DnsKey{\n            domain: BoundedVec::from_array(\"com.\".as_bytes()),\n            key_x: [\n                183 as u8,\n                31 as u8,\n                4 as u8,\n                101 as u8,\n                16 as u8,\n                29 as u8,\n                219 as u8,\n                226 as u8,\n                191 as u8,\n                12 as u8,\n                148 as u8,\n                85 as u8,\n                209 as u8,\n                47 as u8,\n                161 as u8,\n                108 as u8,\n                28 as u8,\n                218 as u8,\n                68 as u8,\n                244 as u8,\n                191 as u8,\n                27 as u8,\n                162 as u8,\n                85 as u8,\n                52 as u8,\n                24 as u8,\n                173 as u8,\n                31 as u8,\n                58 as u8,\n                169 as u8,\n                176 as u8,\n                105 as u8\n            ],\n            key_y: [ \n                115 as u8,\n                242 as u8,\n                27 as u8,\n                132 as u8,\n                235 as u8,\n                83 as u8,\n                44 as u8,\n                244 as u8,\n                3 as u8,\n                94 as u8,\n                232 as u8,\n                212 as u8,\n                131 as u8,\n                44 as u8,\n                162 as u8,\n                109 as u8,\n                137 as u8,\n                48 as u8,\n                106 as u8,\n                125 as u8,\n                50 as u8,\n                86 as u8,\n                12 as u8,\n                12 as u8,\n                176 as u8,\n                18 as u8,\n                157 as u8,\n                69 as u8,\n                10 as u8,\n                193 as u8,\n                8 as u8,\n                53 as u8,\n            ]\n        }.pack();\n        storage.keysigkey_64bytes.at(pedersen_hash(the)).write(\n            // (\n            //     the, \n                true\n            // )\n        );\n    }\n\n    // estimation of max length of a DNSKEY record, can be calculated precisely beyond the prototype #calculatonEstimation\n    // a big reserved space, [a recommended maximum is 13 but some systems allow much higher (which open those for an attack)](https://datatracker.ietf.org/meeting/121/materials/slides-121-dnsop-sessb-dns-upper-limit-values-00)\n    #[derive(Deserialize, Serialize)]\n    pub struct DnskeyRecordSetBytes {bytes: BoundedVec<\n        u8, 333 // * 4 // * 8 // * 16 // TODO actually this already covers most of the setups, but there's some ways to combine a big `RRset` from parts with enough development invested in this\n    >}\n    \n    #[public]\n    fn add_zsigk_len64_signed_ecdsa256sha256(\n        // ksigk_x: [u8; 32],\n        // ksigk_y: [u8; 32],\n        // domain: Fqdn,\n        ksigk: Bytes64DnsKey,\n        domain_rrset_position: u32,\n        ksigk_rrset_position: u32,\n        // delegationsigner: _,\n        rrset_dnskey: DnskeyRecordSetBytes, \n        rrsig_dnskey: [u8; 64],\n        zsigk_x: [u8; 32],\n        zsigk_y: [u8; 32],\n        zsigk_rrset_position: u32,\n    ) {\n        assert(storage.keysigkey_64bytes.at(pedersen_hash(ksigk.pack())).read(), \"the key have been revoked or never added\"); \n\n        let mut rrset_dnskey = rrset_dnskey;\n        for i in 0..ksigk.domain.len() {\n            rrset_dnskey.bytes.set_unchecked(domain_rrset_position + i, ksigk.domain.get(i));\n        }\n        for i in 0..32 {\n            rrset_dnskey.bytes.set_unchecked(ksigk_rrset_position + i, ksigk.key_x[i]);\n            rrset_dnskey.bytes.set_unchecked(ksigk_rrset_position + i + 32, ksigk.key_y[i]);\n            rrset_dnskey.bytes.set_unchecked(zsigk_rrset_position + i, zsigk_x[i]);\n            rrset_dnskey.bytes.set_unchecked(zsigk_rrset_position + i + 32, zsigk_y[i]);\n        }\n\n        let h: [u8; 32] = dep::sha256::sha256_var(\n                rrset_dnskey.bytes.storage(), rrset_dnskey.bytes.len() as u64\n            );\n        assert(std::ecdsa_secp256r1::verify_signature(\n            // ksigk.key[0..32], ksigk.key[32..64], \n            ksigk.key_x, ksigk.key_y,\n            rrsig_dnskey, h\n        ));\n\n        // storage.zonesigkey_64bytes.at(pedersen_hash(Bytes64DnsKey{\n        //     domain: ksigk.domain, key_x: zsigk_x, key_y: zsigk_y\n        // }.pack())).write(true);\n    }\n\n    // // #calculatonEstimation\n    // #[derive(Deserialize, Serialize)]\n    // pub struct DsRecordSetBytes {bytes: BoundedVec<u8, 289 * 2>} // ~~feels like it makes no sense to design for more than one record in a set here~~ #singleDS\n    \n    // #[public]\n    // fn add_ds_ecdsa(\n    //     parent_zsigk: Bytes64DnsKey,\n    //     rrset_ds: DsRecordSetBytes,\n    //     child_ksigk: Bytes64DnsKey,\n    //     // ~~with #singleDS it's possible to say that the child domain position is `0`~~\n    //     child_domain_position: u32,\n    //     ksigk_rrset_position: u32,\n    //     rrsig_ds: [u8; 64],\n    // ) {\n    //     assert(storage.zonesigkey_64bytes.at(pedersen_hash(parent_zsigk.pack())).read(), \"the key have been revoked or never added\"); \n\n    //     let l_child = child_ksigk.domain.len();\n    //     let l_parent = parent_zsigk.domain.len();\n    //     // assert(\".\".as_bytes()[0] == child_ksigk.domain.get(l_child - l_parent), \"DS must define a subdomain\");\n    //     let mut rrset_ds = rrset_ds;\n    //     for i in 0..(l_child - l_parent) {\n    //         rrset_ds.bytes.set_unchecked(i + child_domain_position, child_ksigk.domain.get(i));\n    //     }\n    //     for i in 0..l_parent {\n    //         // assert(parent_zsigk.domain.get(i) == child_ksigk.domain.get(i + l_child - l_parent), \"DS must define a subdomain\");\n    //         rrset_ds.bytes.set_unchecked(\n    //             i + child_domain_position + l_child, parent_zsigk.domain.get(i)\n    //         );\n    //     }\n    //     for i in 0..32 {\n    //         rrset_ds.bytes.set_unchecked(ksigk_rrset_position + i, child_ksigk.key_x[i]);\n    //         rrset_ds.bytes.set_unchecked(ksigk_rrset_position + i + 32, child_ksigk.key_y[i]);\n    //     }\n\n    //     let sig_check = std::ecdsa_secp256r1::verify_signature(\n    //         parent_zsigk.key_x, parent_zsigk.key_y,\n    //         rrsig_ds, dep::sha256::sha256_var(\n    //             rrset_ds.bytes.storage(), rrset_ds.bytes.len() as u64\n    //         )\n    //     );\n    //     assert(sig_check);\n\n    //     storage.keysigkey_64bytes.at(pedersen_hash(child_ksigk.pack())).write(true);\n    // }\n\n    // global dkim_label: [u8; 10] = \"_domainkey\".as_bytes();\n    // global dot_byte: u8 = \".\".as_bytes()[0];\n    // #[derive(Deserialize, Serialize)]\n    // pub struct DkimKeyRsa2048 {\n    //     domain: Fqdn,\n    //     selector: BoundedVec<u8, 63>,\n    //     key: [u8; 256]\n    // }\n    // global LenPackedDkimKeyRsa2048: u32 = 256 + 1 + FqdnMaxLen + 1 + 63;\n    // impl Packable<LenPackedDkimKeyRsa2048> for DkimKeyRsa2048 {\n    //     fn pack(self) -> [Field; LenPackedDkimKeyRsa2048] {\n    //         let l_domain = self.domain.len();\n    //         let l_selector = self.selector.len();\n    //         let mut r_domain = [0; FqdnMaxLen + 1];\n    //         for i in 0..l_domain {\n    //             r_domain[i] = self.domain.get(i) as Field;\n    //         }\n    //         r_domain[FqdnMaxLen] = l_domain as Field;\n    //         let mut r_selector = [0; 63 + 1];\n    //         for i in 0..l_selector {\n    //             r_selector[i] = self.selector.get(i) as Field;\n    //         }\n    //         r_selector[63] = l_selector as Field;\n            \n    //         r_domain.concat(r_selector).concat(self.key.map(|b| b as Field))\n    //     }\n    //     fn unpack(packed: [Field; LenPackedDkimKeyRsa2048]) -> Self {\n    //         let mut d: [u8; FqdnMaxLen] = [0; FqdnMaxLen];\n    //         let mut s: [u8; 63] = [0; 63];\n    //         let mut key: [u8; 256] = [0; 256];\n    //         for i in 0..FqdnMaxLen {d[i] = packed[i] as u8;}\n    //         for i in 0..63 {s[i] = packed[i + FqdnMaxLen + 1] as u8;}\n    //         for i in 0..256 {\n    //             key[i] = packed[i + FqdnMaxLen + 1 + 63 + 1] as u8;\n    //         }\n    //         DkimKeyRsa2048{\n    //             domain: BoundedVec::from_parts_unchecked(d, packed[FqdnMaxLen] as u32),\n    //             selector: BoundedVec::from_parts_unchecked(s, packed[FqdnMaxLen + 1 + 63] as u32),\n    //             key\n    //         }\n    //     }\n    // }\n    // // #calculatonEstimation\n    // #[derive(Deserialize, Serialize)]\n    // pub struct DkimRecordRsa2048 {\n    //     bytes: BoundedVec<u8, 263 + FqdnMaxLen>,\n    // }\n    // #[public]\n    // fn add_dkim_rsa2048_signed_ecdsa256sha256(\n    //     parts: DkimKeyRsa2048,\n    //     record: DkimRecordRsa2048,\n    //     dkim_key_position: u32,\n    //     rrsig: [u8; 64],\n    //     zsigk_x: [u8; 32],\n    //     zsigk_y: [u8; 32],\n    // ) {\n    //     assert(storage.zonesigkey_64bytes.at(pedersen_hash(\n    //         Bytes64DnsKey{domain: parts.domain, key_x: zsigk_x, key_y: zsigk_y}\n    //         .pack()\n    //     )).read());\n        \n    //     let mut record = record.bytes;\n    //     let l_selector = parts.selector.len();\n    //     // let index_dot_first = l_selector;\n    //     // let index_dkim_label = index_dot_first + 1;\n    //     // let index_dot_second = index_dot_first + 1 + 10;\n    //     // let index_domain_start = index_dot_second + 1;\n    //     for i in 0..l_selector {\n    //         record.set_unchecked(i, parts.selector.get_unchecked(i)); // TODO there were a lot of `get` to switch \n    //     }\n    //     record.set_unchecked(l_selector, dot_byte); \n    //     // for i in ()..index_dot_second {\n    //     for i in 0..10 {\n    //         record.set_unchecked(i + l_selector + 1, dkim_label[i]); \n    //     }\n    //     record.set_unchecked(l_selector + 1 + 10, dot_byte); \n    //     // for i in ..( + index_domain_start) {\n    //     for i in 0..parts.domain.len() {\n    //         record.set_unchecked(i + l_selector + 1 + 10 + 1, parts.domain.get(i)); \n    //     }\n    //     for i in 0..256 {\n    //         record.set_unchecked(i + dkim_key_position, parts.key[i]); \n    //     }\n\n    //     let sig_check = std::ecdsa_secp256r1::verify_signature(\n    //         zsigk_x, zsigk_y,\n    //         rrsig, dep::sha256::sha256_var(\n    //             record.storage(), record.len() as u64\n    //         )\n    //     );\n    //     assert(sig_check);\n\n    //     storage.dkimkey_rsa2048.at(pedersen_hash(parts.pack())).write(true);\n    // }\n\n    // #[public]\n    // fn check_rsa2048(the: DkimKeyRsa2048) {\n    //     assert(storage.dkimkey_rsa2048.at(pedersen_hash(the.pack())).read());\n    // }\n    \n    // TODO a lib function since adding a DKIM key which needs an additional trust assumption isn't acceptable; but quite verifiable as an addition\n    // should only be used if the caller trusts the delegated domain\n    // fn add_dkim_rsa2048_delegated_signed_ecdsa256sha256() {}\n\n    // AFAIK DKIM has no revokation mechanism so it can be done by revealing the private key to the contract publicly. Sadly privately won't make this as that would allow the key owner to mark it revoked for this contract only.\n}\n\n#[test]\nfn test_paypalcom_pp_ndash_dkim1_txt() {\n    assert(std::ecdsa_secp256r1::verify_signature(\n        [\n            63,\n            205,\n            154,\n            30,\n            253,\n            187,\n            190,\n            55,\n            132,\n            12,\n            194,\n            84,\n            134,\n            245,\n            60,\n            127,\n            77,\n            150,\n            247,\n            245,\n            158,\n            110,\n            91,\n            47,\n            124,\n            192,\n            139,\n            251,\n            44,\n            12,\n            16,\n            152,\n        ],\n        [\n            3,\n            255,\n            220,\n            108,\n            69,\n            43,\n            105,\n            56,\n            152,\n            89,\n            11,\n            209,\n            48,\n            103,\n            137,\n            208,\n            6,\n            195,\n            252,\n            174,\n            80,\n            57,\n            174,\n            28,\n            151,\n            101,\n            240,\n            92,\n            129,\n            207,\n            59,\n            238,\n        ],\n        [\n            133,\n            3,\n            79,\n            178,\n            129,\n            65,\n            2,\n            67,\n            119,\n            121,\n            165,\n            221,\n            220,\n            168,\n            254,\n            139,\n            229,\n            14,\n            138,\n            199,\n            185,\n            203,\n            214,\n            105,\n            252,\n            73,\n            216,\n            223,\n            47,\n            213,\n            33,\n            17,\n            40,\n            67,\n            22,\n            254,\n            64,\n            169,\n            83,\n            144,\n            131,\n            79,\n            44,\n            126,\n            28,\n            103,\n            221,\n            246,\n            253,\n            57,\n            66,\n            124,\n            94,\n            234,\n            91,\n            47,\n            79,\n            204,\n            187,\n            66,\n            116,\n            248,\n            80,\n            3,\n        ],\n        [190, 104, 21, 63, 5, 38, 46, 193, 97, 171, 69, 178, 157, 245, 203, 13, 99, 150, 97, 252, 242, 185, 185, 207, 130, 121, 103, 47, 81, 243, 19, 55]\n    ));\n}\n\n#[test]\nfn test_ecdsa_com_dnskey() {\n    assert(std::ecdsa_secp256r1::verify_signature(\n        [\n            183,\n            31,\n            4,\n            101,\n            16,\n            29,\n            219,\n            226,\n            191,\n            12,\n            148,\n            85,\n            209,\n            47,\n            161,\n            108,\n            28,\n            218,\n            68,\n            244,\n            191,\n            27,\n            162,\n            85,\n            52,\n            24,\n            173,\n            31,\n            58,\n            169,\n            176,\n            105,\n        ],\n        [\n            115,\n            242,\n            27,\n            132,\n            235,\n            83,\n            44,\n            244,\n            3,\n            94,\n            232,\n            212,\n            131,\n            44,\n            162,\n            109,\n            137,\n            48,\n            106,\n            125,\n            50,\n            86,\n            12,\n            12,\n            176,\n            18,\n            157,\n            69,\n            10,\n            193,\n            8,\n            53,\n        ],\n        [\n            40,\n            4,\n            14,\n            209,\n            3,\n            30,\n            39,\n            182,\n            205,\n            32,\n            153,\n            102,\n            68,\n            4,\n            4,\n            132,\n            22,\n            49,\n            92,\n            23,\n            170,\n            229,\n            202,\n            1,\n            220,\n            28,\n            115,\n            184,\n            93,\n            60,\n            190,\n            131,\n            7,\n            139,\n            125,\n            206,\n            153,\n            177,\n            111,\n            218,\n            116,\n            239,\n            233,\n            28,\n            125,\n            232,\n            107,\n            251,\n            220,\n            79,\n            24,\n            150,\n            238,\n            245,\n            133,\n            83,\n            224,\n            105,\n            154,\n            192,\n            149,\n            2,\n            56,\n            235,\n        ],\n        [144, 246, 38, 118, 139, 81, 41, 183, 88, 81, 151, 57, 40, 52, 222, 50, 229, 112, 139, 75, 134, 246, 227, 200, 175, 30, 32, 88, 4, 32, 197, 56]\n    ));\n}\n\n\n// #[test]\n// fn test_rsa() {\n//     let params: BigNumParams<9, 1024> = BigNumParams::new(\n//         false,\n//         [0x9b5f6367e94c0d47502451357be1b5, 0x2cf79e792ab501e6a8a1ca519af2cb, 0x3af9c9fc1c5466fb684cf009d7197c, 0xe2941992548cee0d67dd4547e11dd6, 0xcb8d5735b9321db085f1b8e2d8038f, 0xbe4ab0caea759e2f773a1f9029c73e, 0xbeb2aaa5b3778d6eebfba6bf9ea191, 0x2f21681bf6d6aba555032bf6f9f036, 0xc5d232c7c1537c79f4b7ac28ff1168],\n//         [0x76587ae99144b02f5c0561abe7b171, 0x572705d030eba70862781acd71f9db, 0xbf7332c0b01314b98e6e4b4e779bb7, 0x1fcde23d91266af32660e5a1c07804, 0xf2f65cfe7bb21f91c71480ddc7e187, 0xd5a265ca080f426885f31564eb35a5, 0x3c9aa2fe848c273cd5f5248fd1eeb1, 0xe3665a614a6a26b98594f893a7eba8, 0xab2d9c34eba3f025bc64776b917622]\n//     );\n//     let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum::from_array(\n//         params,\n//         [0x8e24b00c41f4f76c69edc9794e596d, 0xf56024369222a279178234d9b256b8, 0x21c8dbe808e3c0e9c5968deb4d8126, 0x25550a447219a6b82f7b48f722034c, 0x1d90802722814b6b8f1d01c6ebbfe3, 0x7bcc51de0c8b896cd4f3403eadcec8, 0x57e9e8bcb4979c3e3aa4b7eca8e475, 0x1363a2f15f0187cb42739e0c78cc4e, 0xaef740a3591cf9c63ae660790309c8]\n//     );\n//     assert(\n//         dep::noir_rsa::rsa::verify_sha256_pkcs1v15(\n//             [9, 77, 116, 176, 84, 37, 6, 44, 24, 67, 19, 129, 158, 130, 151, 108, 31, 225, 126, 224, 106, 117, 67, 255, 37, 232, 114, 47, 53, 50, 58, 197],\n//             signature,\n//             65537\n//         )\n//     );\n// }\n\n// #[test]\n// fn test_() {\n//     let digest: [u8; 32] = [117, 9, 229, 189, 160, 199, 98, 210, 186, 199, 249, 13, 117, 139, 91, 34, 99, 250, 1, 204, 188, 84, 42, 181, 227, 223, 22, 59, 224, 142, 108, 169];\n//     let params: BigNumParams<18, 2048> = BigNumParams::new(\n//             false,\n//             [0x320e3fd2ac91530fe87c5d0339b8c9, 0xdcfcf6c4978ba5a1ab88d406fb8094, 0xd5800612e4755aadb37370a240ff81, 0x738c3aa64681506730592ae9bc5fda, 0x9f8f701c911e725bee1be0742e1a6, 0x618dc82e8b2f0c3b842a11320a1858, 0x8547c03d7d1611d40c0344533faec0, 0x116aa47d00b47cf2a0020d79fa110b, 0x5b69aa3379c07357141ddb0249c21c, 0x5f5b575ac974112172940e552a7c97, 0xb9eca24d9f9e3e5e4dbccab76fc193, 0xfbfa167ac05f078fb7cc54c60d1548, 0x5f128d3d960d7497dee19ad6289ac3, 0x6bce971aecb172b0467c6df9a28468, 0xd000ba73583754f889bef2292da312, 0x531040c99d3fd0bb263c7473558d2b, 0xa31efbce2d858a18e6d05f0b5a342, 0xc8],\n//             [0x4c617696e76c6bd4f122b047fa4adc, 0xaafca25e2d7a639297e9c5cbbc8eb2, 0x6617645454da971978476ad086a375, 0x29a916c613f74464dedcddbddb67d3, 0xb48b3a7c550ee255ee7ad8c9698871, 0xc3e3d3169e61d41cc8388cd0bb3194, 0x72ee3ff094ea1b9296492366fe398a, 0x5ae7cd9c1ed1cfb4b7db2ec08b5736, 0xe880c9b01edd7fa6340fb8d241d6a2, 0x81899f93b28c12576b2dcd9c1a9022, 0x7e77a5751db46645c3288fdc6e22ba, 0x4ee17e658ad069f5a4b66786e0060e, 0x5c6009ab0795ccee11ff3d61209aee, 0x7faa3258374dfbe06c22ab4ecb4080, 0x6cef1c8040327dd9880068218d96e9, 0x72e57b7ab70200f25fab2054f45c28, 0xd61361cf599ca7656c7ecacacbe52e, 0x1479]\n//     );\n//     let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum::from_array(\n//             params,\n//             [0x318b6c033614d835d06df0c7369b98, 0xa910f3dc3b06ef82fded2b512a0a79, 0x64bbf6d55bec9375b814f49a1ab7d2, 0x8bbc90ce50513a94225de5ae2002fb, 0x60e5c156686a41718ff42e6d0dd03f, 0x189b04e18d3f06e00d928f0d09a369, 0x5993e8301d6f23c4f4a037516bdb52, 0x096744117a22b0af39aae83631a4ae, 0xb530abb5eb0b87cdfcbd95e3d711bd, 0x186f03693c2103aa3e8eb1bfac0f8b, 0x6f236b019a3f699ea8cc7156e3cbcc, 0xa2dcbc81eeccc739646cdaebcf2006, 0x89e8b63cf8ad3bfe264ad99f4a76fd, 0x32751797dc531f01e08a6bfd687e15, 0xb2706ca49b1f65fa0a20617e21c7ef, 0xdf0e9db7c28c62c8bd3b00564ca49e, 0xdc5549da818ceac23c2436571eff47, 0x84]\n//     );\n//     // assert(\n//         dep::noir_rsa::rsa::verify_sha256_pkcs1v15(\n//             digest,\n//             signature,\n//             65537\n//         );\n//     // );\n// }","path":"/home/serge/Desktop/dkim_registry_dnssec/src/main.nr"},"60":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_FIELD_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl PublicContext {\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    pub fn emit_public_log<T, let N: u32>(_self: &mut Self, log: T)\n    where\n        T: Serialize<N>,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index) } == 1\n    }\n\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_FIELD_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_FIELD_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    pub fn block_number(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n    pub fn fee_per_l2_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_l2_gas()\n        }\n    }\n    pub fn fee_per_da_gas(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            fee_per_da_gas()\n        }\n    }\n\n    pub fn l2_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n    pub fn da_gas_left(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    pub fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    pub fn storage_write<T, let N: u32>(self, storage_slot: Field, value: T)\n    where\n        T: Packable<N>,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> Field {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: Field,\n    da_gas_allocation: Field,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"62":{"source":"use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let contract_address = get_contract_address();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T, let N: u32>(self, storage_slot: Field) -> T\n    where\n        T: Packable<N>,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"88":{"source":"use super::utils::compute_fn_selector;\nuse std::panic;\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn size_in_fields(typ: Type) -> u32 {\n    let size = array_size_in_fields(typ);\n    let size = size.or_else(|| bool_size_in_fields(typ));\n    let size = size.or_else(|| constant_size_in_fields(typ));\n    let size = size.or_else(|| field_size_in_fields(typ));\n    let size = size.or_else(|| int_size_in_fields(typ));\n    let size = size.or_else(|| str_size_in_fields(typ));\n    let size = size.or_else(|| struct_size_in_fields(typ));\n    let size = size.or_else(|| tuple_size_in_fields(typ));\n    if size.is_some() {\n        size.unwrap()\n    } else {\n        panic(f\"Can't determine size in fields of {typ}\")\n    }\n}\n\ncomptime fn array_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_array().and_then(|typ: (Type, Type)| {\n        let (typ, element_size) = typ;\n        element_size.as_constant().map(|x: u32| x * size_in_fields(typ))\n    })\n}\n\ncomptime fn bool_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_bool() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn field_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.is_field() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn int_size_in_fields(typ: Type) -> Option<u32> {\n    if typ.as_integer().is_some() {\n        Option::some(1)\n    } else {\n        Option::none()\n    }\n}\n\ncomptime fn constant_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_constant()\n}\n\ncomptime fn str_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_str().map(|typ| size_in_fields(typ))\n}\n\ncomptime fn struct_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_data_type().map(|typ: (TypeDefinition, [Type])| {\n        let struct_type = typ.0;\n        let generics = typ.1;\n        let mut size = 0;\n        for field in struct_type.fields(generics) {\n            size += size_in_fields(field.1);\n        }\n        size\n    })\n}\n\ncomptime fn tuple_size_in_fields(typ: Type) -> Option<u32> {\n    typ.as_tuple().map(|types: [Type]| {\n        let mut size = 0;\n        for typ in types {\n            size += size_in_fields(typ);\n        }\n        size\n    })\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"92":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"95":{"source":"use crate::macros::{\n    functions::{abi_export::create_fn_abi_export, call_interface_stubs::stub_fn, stub_registry},\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_noinitcheck, get_fn_visibility, is_fn_contract_library_method,\n        is_fn_initializer, is_fn_internal, is_fn_private, is_fn_public, is_fn_test, is_fn_utility,\n        is_fn_view, modify_fn_body, module_has_initializer, module_has_storage,\n    },\n};\nuse protocol_types::meta::generate_serialize_to_fields;\nuse std::meta::type_of;\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[private] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    let to_prepend = quote {\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) -> Quoted {\n    let fn_abi = create_fn_abi_export(f);\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // If a function is further modified as unconstrained, we throw an error\n    if f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[public] but marked as unconstrained, remove unconstrained keyword\",\n        );\n    }\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n    let args_len = original_params\n        .map(|(name, typ): (Quoted, Type)| {\n            generate_serialize_to_fields(name, typ, false).0.len()\n        })\n        .fold(0, |acc: u32, val: u32| acc + val);\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len] = dep::aztec::context::public_context::calldata_copy(1, $args_len);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n\n    fn_abi\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    // Check if function is marked as unconstrained\n    if !f.is_unconstrained() {\n        let name = f.name();\n        panic(\n            f\"Function {name} is annotated with #[utility] but not marked as unconstrained, add unconstrained keyword\",\n        );\n    }\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process. This is slightly inefficient and could be improved by only doing it once we actually\n    // attempt to read any.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject context creation, storage initialization, and message discovery call at the beginning of the function\n    // body.\n    let to_prepend = quote {\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call == true, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr"},"98":{"source":"use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\nuse super::utils::is_note;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract. Only a single struct in the entire contract\n/// should have this macro (or `storage_no_init`) applied to it.\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot }, false);\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields =\n            storage_layout_fields.push_back(quote { pub $name: dep::aztec::prelude::Storable });\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::prelude::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n/// Only a single struct in the entire contract should have this macro (or `storage`) applied to it.\npub comptime fn storage_no_init(_s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(\n    typ: Type,\n    slot: Quoted,\n    parent_is_map: bool,\n) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot }, true);\n        (quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }, 1)\n    } else {\n        let storage_size = if parent_is_map {\n            // Variables inside a map do not require contiguous slots since the map slot derivation is assumed to result\n            // in slots very far away from one another.\n            1\n        } else {\n            let (_, container_struct_generics) = typ.as_data_type().unwrap();\n            let stored_struct = container_struct_generics[0];\n\n            if is_note(stored_struct) {\n                // Private notes always occupy a single slot, since the slot is only used as a state variable\n                // identifier.\n                1\n            } else {\n                get_storage_size(typ)\n            }\n        };\n\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        (quote { $struct_name::new(context, $slot)}, storage_size)\n    }\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/macros/storage.nr"},"137":{"source":"use dep::protocol_types::address::AztecAddress;\n\n#[oracle(getContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(getBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(getChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(getVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"139":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> (Field, bool) {}\n\npub unconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_deployer_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_class_id_oracle_avm(address)\n}\npub unconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> (Field, bool) {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_deployer_internal_avm(address) };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) = unsafe { get_contract_instance_class_id_internal_avm(address) };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let (member, exists) =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address) };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"154":{"source":"use crate::state_vars::storage::Storage;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::{Packable, ToField}};\n\n// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\nimpl<K, T, Context, let N: u32> Storage<N> for Map<K, T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"163":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::Storage;\nuse dep::protocol_types::traits::Packable;\n\n// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let N: u32> Storage<N> for PublicMutable<T, Context>\nwhere\n    T: Packable<N>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<let T_PACKED_LEN: u32>(self, value: T)\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    pub unconstrained fn read<let T_PACKED_LEN: u32>(self) -> T\n    where\n        T: Packable<T_PACKED_LEN>,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"199":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/serge/nargo/github.com/noir-lang/poseidon/v0.1.0/src/poseidon2.nr"},"218":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\n\npub struct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    pub inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self { inner: fields[0] as u32 }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"261":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\n\n// Aztec address\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other: Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\n/// We implement the Packable trait for AztecAddress because it can be stored in contract's storage (and there\n/// the implementation of Packable is required).\nimpl Packable<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn pack(self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        self.serialize()\n    }\n\n    fn unpack(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        Self::deserialize(fields)\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"279":{"source":"use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        contract_class_log::ContractClassLog,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__OUTER_NULLIFIER,\n        GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::{\n        arrays::{array_concat, unsafe_padded_array_length},\n        field::{field_from_bytes, field_from_bytes_32_trunc},\n    },\n};\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n        compute_unique_note_hash(nonce, siloed_note_hash)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog { fields }\n    }\n}\n\nfn compute_siloed_contract_class_log_field(\n    contract_address: AztecAddress,\n    first_field: Field,\n) -> Field {\n    poseidon2_hash([contract_address.to_field(), first_field])\n}\n\npub fn silo_contract_class_log(contract_class_log: ContractClassLog) -> ContractClassLog {\n    if contract_class_log.contract_address.is_zero() {\n        contract_class_log\n    } else {\n        let mut log = contract_class_log;\n        log.log.fields[0] = compute_siloed_contract_class_log_field(\n            contract_class_log.contract_address,\n            log.log.fields[0],\n        );\n        log\n    }\n}\n\npub fn compute_contract_class_log_hash(contract_class_log: ContractClassLog) -> Field {\n    let array = contract_class_log.log.fields;\n    // Safety: The below length is constrained in the base rollup.\n    let length = unsafe { unsafe_padded_array_length(array) };\n    if length == 0 {\n        0\n    } else {\n        poseidon2_hash(array)\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let mut bytes: [u8; 160] = std::mem::zeroed();\n\n    let inputs =\n        [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..5 {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes: [u8; 32] = inputs[i].to_be_bytes();\n        for j in 0..32 {\n            bytes[32 * i + j] = item_bytes[j];\n        }\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: ScopedL2ToL1Message,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a u128.\n    // 4 Field elements when converted to bytes will usually\n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field\n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes: [u8; 32] = input[offset].to_be_bytes();\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\npub fn verification_key_hash<let N: u32>(key: [Field; N]) -> Field {\n    crate::hash::poseidon2_hash(key)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = array_concat([separator.to_field()], inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert(input[in_len - remainder + i] == 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        ScopedL2ToL1Message {\n            message: L2ToL1Message { recipient: EthAddress::from_field(1), content: 2, counter: 0 },\n            contract_address: AztecAddress::from_field(3),\n        },\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `l2_to_l1_message.test.ts`\n    let hash_from_typescript = 0x00c6155d69febb9d5039b374dd4f77bf57b7c881709aa524a18acaa0bd57476a;\n\n    assert_eq(hash, hash_from_typescript);\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"293":{"source":"use super::traits::{Deserialize, Packable, Serialize};\n\n/// Returns the typed expression of a trait method implementation.\n///\n/// This helper function is preferred over directly inlining with `$typ::target_method()` in a quote,\n/// as direct inlining would result in missing import warnings in the generated code (specifically,\n/// warnings that the trait implementation is not in scope).\n///\n/// # Note\n/// A copy of this function exists in `aztec-nr/aztec/src/macros/utils.nr`. We maintain separate copies\n/// because importing it there from here would cause the `target_trait` to be interpreted in the context\n/// of this crate, making it impossible to compile code for traits from that crate (e.g. NoteType).\ncomptime fn get_trait_impl_method(\n    typ: Type,\n    target_trait: Quoted,\n    target_method: Quoted,\n) -> TypedExpr {\n    let trait_constraint = target_trait.as_trait_constraint();\n    typ\n        .get_trait_impl(trait_constraint)\n        .expect(f\"Could not find impl for {target_trait} for type {typ}\")\n        .methods()\n        .filter(|m| m.name() == target_method)[0]\n        .as_typed_expr()\n}\n\n/// Generates code that deserializes a struct, primitive type, array or string from a field array.\n///\n/// # Parameters\n/// - `name`: The name of the current field being processed, used to identify fields for replacement.\n/// - `typ`: The type of the struct or field being deserialized (e.g., a custom struct, array, or primitive).\n/// - `field_array_name`: The name of the field array containing serialized field data (e.g., `\"values\"`).\n/// - `num_already_consumed`: The number of fields already processed in previous recursion calls.\n/// - `should_unpack`: A boolean indicating whether the type should be unpacked (see description of `Packable`\n/// and `Serialize` trait for more information about the difference between packing and serialization).\n///\n/// # Returns\n/// A tuple containing:\n/// - `Quoted`: A code that deserializes a given struct, primitive type, array, or string from the field array.\n/// - `u32`: The total number of fields consumed during deserialization (used for recursion).\n///\n/// # Nested Struct Example\n/// Given the following setup:\n/// ```\n/// struct UintNote {\n///     value: u128,\n///     owner: AztecAddress,\n///     randomness: Field,\n/// }\n///\n/// struct AztecAddress {\n///     inner: Field,\n/// }\n/// ```\n///\n/// If `UintNote` is the input type, the function will generate the following deserialization code:\n/// ```\n/// UintNote {\n///     value: fields[0] as u128,\n///     owner: AztecAddress {\n///         inner: fields[1],\n///     },\n///     randomness: fields[2],\n/// }\n/// ```\n/// # Nested Struct Example with Unpacking\n/// - given the same setup as above and given that u128, AztecAddress and Field implement the `Packable` trait\n///   the result we get is:\n/// ```\n/// UintNote {\n///     value: aztec::protocol_types::traits::Packable::unpack([fields[0]]),\n///     owner: aztec::protocol_types::traits::Packable::unpack([fields[1]]),\n///     randomness: aztec::protocol_types::traits::Packable::unpack([fields[2]]),\n/// }\n/// ```\n///\n/// # Panics\n/// - If the deserialization logic encounters a type it does not support.\n/// - If an incorrect number of fields are consumed when deserializing a string.\npub comptime fn generate_deserialize_from_fields(\n    name: Quoted,\n    typ: Type,\n    field_array_name: Quoted,\n    num_already_consumed: u32,\n    should_unpack: bool,\n) -> (Quoted, u32) {\n    let mut result = quote {};\n    // Counter for the number of fields consumed\n    let mut consumed_counter: u32 = 0;\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint = quote { Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_unpack & typ.implements(packable_constraint)) {\n        // Unpacking is enabled and the given type implements the `Packable` trait so we call the `unpack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We copy the packed fields into a new array and pass that to the unpack function in a quote\n        let mut packed_fields_quotes = &[];\n        for i in 0..packed_len {\n            let index_in_field_array = i + num_already_consumed;\n            packed_fields_quotes =\n                packed_fields_quotes.push_back(quote { $field_array_name[$index_in_field_array] });\n        }\n        let packed_fields = packed_fields_quotes.join(quote {,});\n\n        // Now we call unpack on the type\n        let unpack_method = get_trait_impl_method(typ, quote { Packable<_> }, quote { unpack });\n        result = quote { $unpack_method([ $packed_fields ]) };\n\n        consumed_counter = packed_len;\n    } else if typ.is_field() | typ.as_integer().is_some() | typ.is_bool() {\n        // The field is a primitive so we just reference it in the field array\n        result = quote { $field_array_name[$num_already_consumed] as $typ };\n        consumed_counter = 1;\n    } else if typ.as_data_type().is_some() {\n        // The field is a struct so we iterate over each struct field and recursively call\n        // `generate_deserialize_from_fields`\n        let (nested_def, generics) = typ.as_data_type().unwrap();\n        let nested_name = nested_def.name();\n        let mut deserialized_fields_list = &[];\n\n        // Iterate over each field in the struct\n        for field in nested_def.fields(generics) {\n            let (field_name, field_type) = field;\n            // Recursively call `generate_deserialize_from_fields` for each field in the struct\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                field_name,\n                field_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `value: u128 { lo: fields[0], hi: fields[1] }`\n            deserialized_fields_list =\n                deserialized_fields_list.push_back(quote { $field_name: $deserialized_field });\n        }\n\n        // We can construct the struct from the deserialized fields\n        let deserialized_fields = deserialized_fields_list.join(quote {,});\n        result = quote {\n                $nested_name {\n                    $deserialized_fields\n                }\n            };\n    } else if typ.as_array().is_some() {\n        // The field is an array so we iterate over each element and recursively call\n        // `generate_deserialize_from_fields`\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        let mut array_fields_list = &[];\n\n        // Iterate over each element in the array\n        for _ in 0..array_len {\n            // Recursively call `generate_deserialize_from_fields` for each element in the array\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                element_type,\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n            // We increment the consumed counter by the number of fields consumed in the recursion\n            consumed_counter += num_consumed_in_recursion;\n            // We add the deserialized field to the list of deserialized fields.\n            array_fields_list = array_fields_list.push_back(deserialized_field);\n        }\n\n        // We can construct the array from the deserialized fields\n        let array_fields = array_fields_list.join(quote {,});\n        result = quote { [ $array_fields ] };\n    } else if typ.as_str().is_some() {\n        // The field is a string and we expect each byte of the string to be represented as 1 field in the field\n        // array. So we iterate over the string length and deserialize each character as u8 in the recursive call\n        // to `generate_deserialize_from_fields`.\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let mut byte_list = &[];\n\n        // Iterate over each character in the string\n        for _ in 0..str_len {\n            // Recursively call `generate_deserialize_from_fields` for each character in the string\n            let (deserialized_field, num_consumed_in_recursion) = generate_deserialize_from_fields(\n                name,\n                quote {u8}.as_type(),\n                field_array_name,\n                consumed_counter + num_already_consumed,\n                should_unpack,\n            );\n\n            // We should consume just one field in the recursion so we sanity check that\n            assert_eq(\n                num_consumed_in_recursion,\n                1,\n                \"Incorrect number of fields consumed in string deserialization\",\n            );\n\n            // We increment the consumed counter by 1 as we have consumed one field\n            consumed_counter += 1;\n\n            // We add the deserialized field to the list of deserialized fields.\n            // E.g. `fields[6] as u8`\n            byte_list = byte_list.push_back(deserialized_field);\n        }\n\n        // We construct the string from the deserialized fields\n        let bytes = byte_list.join(quote {,});\n        result = quote { [ $bytes ].as_str_unchecked() };\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (result, consumed_counter)\n}\n\n/// Generates code that serializes a type into an array of fields. Also generates auxiliary variables if necessary\n/// for serialization. If `should_pack` is true, we check if the type implements the `Packable` trait and pack it\n/// if it does.\n///\n/// # Parameters\n/// - `name`: The base identifier (e.g., `self`, `some_var`).\n/// - `typ`: The type being serialized (e.g., a custom struct, array, or primitive type).\n/// - `should_pack`: A boolean indicating whether the type should be packed.\n///\n/// # Returns\n/// A tuple containing:\n/// - A flattened array of `Quoted` field references representing the serialized fields.\n/// - An array of `Quoted` auxiliary variables needed for serialization, such as byte arrays for strings.\n///\n/// # Examples\n///\n/// ## Struct\n/// Given the following struct:\n/// ```rust\n/// struct MockStruct {\n///     a: Field,\n///     b: Field,\n/// }\n/// ```\n///\n/// Serializing the struct:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_mock_struct }, MockStruct, false)\n/// // Returns:\n/// // ([`my_mock_struct.a`, `my_mock_struct.b`], [])\n/// ```\n///\n/// ## Nested Struct\n/// For a more complex struct:\n/// ```rust\n/// struct NestedStruct {\n///     m1: MockStruct,\n///     m2: MockStruct,\n/// }\n/// ```\n///\n/// Serialization output:\n/// ```rust\n/// generate_serialize_to_fields(quote { self }, NestedStruct, false)\n/// // Returns:\n/// // ([`self.m1.a`, `self.m1.b`, `self.m2.a`, `self.m2.b`], [])\n/// ```\n///\n/// ## Array\n/// For an array type:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_array }, [Field; 3], false)\n/// // Returns:\n/// // ([`my_array[0]`, `my_array[1]`, `my_array[2]`], [])\n/// ```\n///\n/// ## String\n/// For a string field, where each character is serialized as a `Field`:\n/// ```rust\n/// generate_serialize_to_fields(quote { my_string }, StringType, false)\n/// // Returns:\n/// // ([`my_string_as_bytes[0] as Field`, `my_string_as_bytes[1] as Field`, ...],\n/// // [`let my_string_as_bytes = my_string.as_bytes()`])\n/// ```\n///\n/// ## Nested Struct with packing enabled\n/// - u128 has a `Packable` implementation hence it will be packed.\n///\n/// For a more complex struct:\n/// ```rust\n/// struct MyStruct {\n///     value: u128,\n///     value2: Field,\n/// }\n/// ```\n///\n/// # Panics\n/// - If the type is unsupported for serialization.\n/// - If the provided `typ` contains invalid constants or incompatible structures.\npub comptime fn generate_serialize_to_fields(\n    name: Quoted,\n    typ: Type,\n    should_pack: bool,\n) -> ([Quoted], [Quoted]) {\n    let mut fields = &[];\n    let mut aux_vars = &[];\n\n    // If the type implements `Packable`, its length will be assigned to the `maybe_packed_len_typ` variable.\n    let maybe_packed_len_typ = std::meta::typ::fresh_type_variable();\n    let packable_constraint =\n        quote { crate::traits::Packable<$maybe_packed_len_typ> }.as_trait_constraint();\n\n    if (should_pack & typ.implements(packable_constraint)) {\n        // Packing is enabled and the given type implements the `Packable` trait so we call the `pack()`\n        // method, add the resulting field array to `aux_vars` and each field to `fields`.\n        let packed_len = maybe_packed_len_typ.as_constant().unwrap();\n\n        // We collapse the name to a one that gets tokenized as a single token (e.g. \"self.value\" -> \"self_value\").\n        let name_at_one_token = collapse_to_one_token(name);\n        let packed_struct_name = f\"{name_at_one_token}_aux_var\".quoted_contents();\n\n        // We add the individual fields to the fields array\n        let pack_method = get_trait_impl_method(\n            typ,\n            quote { crate::traits::Packable<$packed_len> },\n            quote { pack },\n        );\n        let packed_struct = quote { let $packed_struct_name = $pack_method($name) };\n        for i in 0..packed_len {\n            fields = fields.push_back(quote { $packed_struct_name[$i] });\n        }\n\n        // We add the new auxiliary variable to the aux_vars array\n        aux_vars = aux_vars.push_back(packed_struct);\n    } else if typ.is_field() {\n        // For field we just add the value to fields\n        fields = fields.push_back(name);\n    } else if typ.as_integer().is_some() | typ.is_bool() {\n        // For integer and bool we just cast to Field and add the value to fields\n        fields = fields.push_back(quote { $name as Field });\n    } else if typ.as_data_type().is_some() {\n        // For struct we pref\n        let nested_struct = typ.as_data_type().unwrap();\n        let params = nested_struct.0.fields(nested_struct.1);\n        let struct_flattened = params.map(|(param_name, param_type): (Quoted, Type)| {\n            let maybe_prefixed_name = if name == quote {} {\n                // Triggered when the param name is of a value available in the current scope (e.g. a function\n                // argument) --> then we don't prefix the name with anything.\n                param_name\n            } else {\n                // Triggered when we want to prefix the param name with the `name` from function input. This\n                // can typically be `self` when implementing a method on a struct.\n                quote { $name.$param_name }\n            };\n            generate_serialize_to_fields(quote {$maybe_prefixed_name}, param_type, should_pack)\n        });\n        let struct_flattened_fields = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (fields, _): (_, [Quoted])| acc.append(fields),\n        );\n        let struct_flattened_aux_vars = struct_flattened.fold(\n            &[],\n            |acc: [Quoted], (_, aux_vars): ([Quoted], _)| acc.append(aux_vars),\n        );\n        fields = fields.append(struct_flattened_fields);\n        aux_vars = aux_vars.append(struct_flattened_aux_vars);\n    } else if typ.as_array().is_some() {\n        // For array we recursively call `generate_serialize_to_fields(...)` for each element\n        let (element_type, array_len) = typ.as_array().unwrap();\n        let array_len = array_len.as_constant().unwrap();\n        for i in 0..array_len {\n            let (element_fields, element_aux_vars) =\n                generate_serialize_to_fields(quote { $name[$i] }, element_type, should_pack);\n            fields = fields.append(element_fields);\n            aux_vars = aux_vars.append(element_aux_vars);\n        }\n    } else if typ.as_str().is_some() {\n        // For string we convert the value to bytes, we store the `as_bytes` in an auxiliary variables and\n        // then we add each byte to fields as a Field\n        let length_type = typ.as_str().unwrap();\n        let str_len = length_type.as_constant().unwrap();\n        let as_member = name.as_expr().unwrap().as_member_access();\n        let var_name = if as_member.is_some() {\n            as_member.unwrap().1\n        } else {\n            name\n        };\n        let as_bytes_name = f\"{var_name}_as_bytes\".quoted_contents();\n        let as_bytes = quote { let $as_bytes_name = $name.as_bytes() };\n        for i in 0..str_len {\n            fields = fields.push_back(quote { $as_bytes_name[$i] as Field });\n        }\n        aux_vars = aux_vars.push_back(as_bytes);\n    } else {\n        panic(\n            f\"Unsupported type for serialization of argument {name} and type {typ}\",\n        )\n    }\n\n    (fields, aux_vars)\n}\n\n/// From a quote that gets tokenized to a multiple tokens we collapse it to a single token by replacing all `.` with `_`.\n/// E.g. \"self.values[0]\" -> \"self_values_0_\"\ncomptime fn collapse_to_one_token(q: Quoted) -> Quoted {\n    let tokens = q.tokens();\n\n    let mut single_token = quote {};\n    for token in tokens {\n        let new_token = if ((token == quote {.}) | (token == quote {[}) | (token == quote {]})) {\n            quote {_}\n        } else {\n            token\n        };\n        single_token = f\"{single_token}{new_token}\".quoted_contents();\n    }\n    single_token\n}\n\npub(crate) comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, false);\n    let aux_vars_for_serialization = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let field_serializations = fields.join(quote {,});\n    let serialized_len = fields.len();\n    quote {\n        impl Serialize<$serialized_len> for $typ {\n            fn serialize(self) -> [Field; $serialized_len] {\n                $aux_vars_for_serialization\n                [ $field_serializations ]\n            }\n        }\n    }\n}\n\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let (fields, _) = generate_serialize_to_fields(quote { self }, typ, false);\n    let serialized_len = fields.len();\n    let (deserialized, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { serialized }, 0, false);\n    quote {\n        impl Deserialize<$serialized_len> for $typ {\n            fn deserialize(serialized: [Field; $serialized_len]) -> Self {\n                $deserialized\n            }\n        }\n    }\n}\n\n/// Generates `Packable` implementation for a given struct and returns the packed length.\n///\n/// Note: We are having this function separate from `derive_packable` because we use this in the note macros to get\n/// the packed length of a note as well as the `Packable` implementation. We need the length to be able to register\n/// the note in the global `NOTES` map. There the length is used to generate partial note helper functions.\npub comptime fn derive_packable_and_get_packed_len(s: TypeDefinition) -> (Quoted, u32) {\n    let packing_enabled = true;\n\n    let typ = s.as_type();\n    let (fields, aux_vars) = generate_serialize_to_fields(quote { self }, typ, packing_enabled);\n    let aux_vars_for_packing = if aux_vars.len() > 0 {\n        let joint = aux_vars.join(quote {;});\n        quote { $joint; }\n    } else {\n        quote {}\n    };\n\n    let (unpacked, _) =\n        generate_deserialize_from_fields(quote { self }, typ, quote { packed }, 0, packing_enabled);\n\n    let field_packings = fields.join(quote {,});\n    let packed_len = fields.len();\n    let packable_trait: TraitConstraint = quote { Packable<$packed_len> }.as_trait_constraint();\n    (\n        quote {\n        impl $packable_trait for $typ {\n            fn pack(self) -> [Field; $packed_len] {\n                $aux_vars_for_packing\n                [ $field_packings ]\n            }\n\n            fn unpack(packed: [Field; $packed_len]) -> Self {\n                $unpacked\n            }\n        }\n    },\n        packed_len,\n    )\n}\n\npub(crate) comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let (packable_impl, _) = derive_packable_and_get_packed_len(s);\n    packable_impl\n}\n\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct Smol {\n    a: Field,\n    b: Field,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct HasArray {\n    a: [Field; 2],\n    b: bool,\n}\n\n#[derive(Serialize, Deserialize, Eq)]\npub struct Fancier {\n    a: Smol,\n    b: [Field; 2],\n    c: [u8; 3],\n    d: str<16>,\n}\n\nfn main() {\n    assert(false);\n}\n\n#[test]\nfn smol_test() {\n    let smol = Smol { a: 1, b: 2 };\n    let serialized = smol.serialize();\n    assert(serialized == [1, 2], serialized);\n    let deserialized = Smol::deserialize(serialized);\n    assert(deserialized == smol);\n\n    // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n    let packed = smol.pack();\n    assert_eq(packed, serialized, \"Packed does not match serialized\");\n}\n\n#[test]\nfn has_array_test() {\n    let has_array = HasArray { a: [1, 2], b: true };\n    let serialized = has_array.serialize();\n    assert(serialized == [1, 2, 1], serialized);\n    let deserialized = HasArray::deserialize(serialized);\n    assert(deserialized == has_array);\n}\n\n#[test]\nfn fancier_test() {\n    let fancier =\n        Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n    let serialized = fancier.serialize();\n    assert(\n        serialized\n            == [\n                1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n            ],\n        serialized,\n    );\n    let deserialized = Fancier::deserialize(serialized);\n    assert(deserialized == fancier);\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"316":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"334":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable<BOOL_PACKED_LEN> for bool {\n    fn pack(self) -> [Field; BOOL_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; BOOL_PACKED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Packable<U8_PACKED_LEN> for u8 {\n    fn pack(self) -> [Field; U8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U8_PACKED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable<U16_PACKED_LEN> for u16 {\n    fn pack(self) -> [Field; U16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U16_PACKED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable<U32_PACKED_LEN> for u32 {\n    fn pack(self) -> [Field; U32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U32_PACKED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable<U64_PACKED_LEN> for u64 {\n    fn pack(self) -> [Field; U64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U64_PACKED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable<U128_PACKED_LEN> for u128 {\n    fn pack(self) -> [Field; U128_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; U128_PACKED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable<FIELD_PACKED_LEN> for Field {\n    fn pack(self) -> [Field; FIELD_PACKED_LEN] {\n        [self]\n    }\n\n    fn unpack(fields: [Field; FIELD_PACKED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable<I8_PACKED_LEN> for i8 {\n    fn pack(self) -> [Field; I8_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I8_PACKED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Packable<I16_PACKED_LEN> for i16 {\n    fn pack(self) -> [Field; I16_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I16_PACKED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Packable<I32_PACKED_LEN> for i32 {\n    fn pack(self) -> [Field; I32_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I32_PACKED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Packable<I64_PACKED_LEN> for i64 {\n    fn pack(self) -> [Field; I64_PACKED_LEN] {\n        [self as Field]\n    }\n\n    fn unpack(fields: [Field; I64_PACKED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Packable<N * M> for [T; N]\nwhere\n    T: Packable<M>,\n{\n    fn pack(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].pack();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    fn unpack(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"335":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U16_SERIALIZED_LEN> for u16 {\n    fn serialize(self) -> [Field; U16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U16_SERIALIZED_LEN> for u16 {\n    fn deserialize(fields: [Field; U16_SERIALIZED_LEN]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for u128 {\n    fn serialize(self) -> [Field; U128_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for u128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; FIELD_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize<I8_SERIALIZED_LEN> for i8 {\n    fn serialize(self) -> [Field; I8_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I8_SERIALIZED_LEN> for i8 {\n    fn deserialize(fields: [Field; I8_SERIALIZED_LEN]) -> Self {\n        fields[0] as i8\n    }\n}\n\nimpl Serialize<I16_SERIALIZED_LEN> for i16 {\n    fn serialize(self) -> [Field; I16_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I16_SERIALIZED_LEN> for i16 {\n    fn deserialize(fields: [Field; I16_SERIALIZED_LEN]) -> Self {\n        fields[0] as i16\n    }\n}\n\nimpl Serialize<I32_SERIALIZED_LEN> for i32 {\n    fn serialize(self) -> [Field; I32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I32_SERIALIZED_LEN> for i32 {\n    fn deserialize(fields: [Field; I32_SERIALIZED_LEN]) -> Self {\n        fields[0] as i32\n    }\n}\n\nimpl Serialize<I64_SERIALIZED_LEN> for i64 {\n    fn serialize(self) -> [Field; I64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<I64_SERIALIZED_LEN> for i64 {\n    fn deserialize(fields: [Field; I64_SERIALIZED_LEN]) -> Self {\n        fields[0] as i64\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Serialize<N * M> for [T; N]\nwhere\n    T: Serialize<M>,\n{\n    fn serialize(self) -> [Field; N * M] {\n        let mut result: [Field; N * M] = std::mem::zeroed();\n        let mut serialized: [Field; M] = std::mem::zeroed();\n        for i in 0..N {\n            serialized = self[i].serialize();\n            for j in 0..M {\n                result[i * M + j] = serialized[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32, let M: u32> Deserialize<N * M> for [T; N]\nwhere\n    T: Deserialize<M>,\n{\n    fn deserialize(fields: [Field; N * M]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; N] = std::mem::zeroed();\n        reader.read_struct_array::<T, M, N>(Deserialize::deserialize, result)\n    }\n}\n\n#[test]\nfn test_u16_serialization() {\n    let a: u16 = 10;\n    assert_eq(a, u16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i8_serialization() {\n    let a: i8 = -10;\n    assert_eq(a, i8::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i16_serialization() {\n    let a: i16 = -10;\n    assert_eq(a, i16::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i32_serialization() {\n    let a: i32 = -10;\n    assert_eq(a, i32::deserialize(a.serialize()));\n}\n\n#[test]\nfn test_i64_serialization() {\n    let a: i64 = -10;\n    assert_eq(a, i64::deserialize(a.serialize()));\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"354":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/serge/nargo/github.com/AztecProtocol/aztec-packages/v0.86.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"364":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/home/serge/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"}}}